<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【旅游】玫瑰花语-1</title>
      <link href="/posts/8e712686.html"/>
      <url>/posts/8e712686.html</url>
      
        <content type="html"><![CDATA[<h2><span id="玫瑰花语-1">玫瑰花语 — 1</span></h2><h3><span id="和糖糖的重庆之旅">和糖糖的重庆之旅</span></h3><p>又是跟着糖糖跑的小可爱一枚噜！贴心得做好了一切攻略的糖糖真的太可靠了！！收获小迷妹一枚！☆▽☆<br><img src="/img/玫瑰花语/1-1.png" width="30%" height="30%" alt> </p><h3><span id="和糖糖的两周年纪念日">和糖糖的两周年纪念日</span></h3><ul><li><p>马上就要到和糖糖的两周年纪念日了，本没有打算在纪念日相聚，但因五一高铁票太过难抢、房间也太过难定的原因，阴差阳错决定提前一周也就是刚好纪念日的那天相聚，这也许是天意吧。<br><img src="/img/玫瑰花语/1-2.png" width="30%" height="30%" alt> </p></li><li><p>终于到了见面的这天，我特地提出了让他带着一束花花来见我的要求，想象着他一路上捧着鲜花过来见我就十分期待，想象着下高铁后看到手捧花花等着我的场景就十分幸福，第一次感觉到时间过得那么那么漫长，心中的雀跃和欣喜似乎怎么都压不住.<br><img src="/img/玫瑰花语/1-3.png" width="30%" height="30%" alt> </p></li><li><p>糖糖是个小呆瓜噜，特地带花花来见我，但是见面的时候都不捧着花花而是用袋袋拎着，冲击力大大降低了好嘛！不过糖糖说下次就知道了，嗯~不知道下次见面是什么时候呢，真想一直和糖糖呆一块。<br><img src="/img/玫瑰花语/1-4.png" width="30%" height="30%" alt> </p></li><li><p>糖糖花了2小时布置的房间和漂亮的花花！！因为我说过糖糖之前送的一只口红味道不太好闻，特地又挑了只香香的口红。<br><img src="/img/玫瑰花语/1-5.png" width="30%" height="30%" alt> </p></li><li><p>和糖糖的情侣装噜！！！开森！！只可惜后两天就降温了，只能和糖糖在晚上穿一次了。本来还想和糖糖一起穿情侣装去学校里面逛来着…呜呜~人算不如天算。<br><img src="/img/玫瑰花语/1-6.png" width="30%" height="30%" alt> </p></li><li><p>糖糖带我去逛了他的学校，下了老大老大的雨，两个人在风里瑟瑟发抖。带我去买了心心念念的烧鸭，但是最后都没吃几口，呜呜呜呜呜~还有巨好吃的新疆餐厅和超级无敌变态辣的牛蛙。<br><img src="/img/玫瑰花语/1-7.png" width="30%" height="30%" alt> </p></li><li><p>妞妞是可爱憨憨宝！</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wzm </tag>
            
            <tag> tyh </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【git】Copilot使用指南</title>
      <link href="/posts/cff33c4a.html"/>
      <url>/posts/cff33c4a.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>（可选）如果有其他建议，可以选择查看。<br>| OS | 查看下一个建议 | 查看上一个建议 |<br>| macOS | <kbd>Option (⌥) 或 Alt</kbd>+<kbd>]</kbd> | <kbd>Option (⌥) 或 Alt</kbd>+<kbd>[</kbd> |<br>| Windows | <kbd>Alt</kbd>+<kbd>]</kbd> | <kbd>Alt</kbd>+<kbd>[</kbd> |<br>| Linux | <kbd>Alt</kbd>+<kbd>]</kbd> | <kbd>Alt</kbd>+<kbd>[</kbd> |<br>若要接受建议，请按<code>Tab</code>。若要拒绝所有建议，请按<code>Esc</code>。</p></li><li><p>打开包含多个附加建议的新选项卡。</p><ul><li>若要打开具有多个其他选项的新选项卡，请按 <kbd>Ctrl</kbd>+<kbd>Enter</kbd>。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> copilot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【计算机系统概论】第二版中译个人心得</title>
      <link href="/posts/3f09c5bf.html"/>
      <url>/posts/3f09c5bf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="第2章-bit-数据类型及其运算-书p14">第2章 bit、数据类型及其运算 书P14</span></h2><h3><span id="23-补码-书p16">2.3 补码 书P16</span></h3><ul><li>在补码的认知上，该节提出了一些很有意思的，我不曾想到的想法，特此记录。<ol><li>补码的好处：对符号相反的两个数求和，加法器能够<strong>直接</strong>对它们<strong>逐位相加</strong>。<ul><li>如真值为13对应补码01101，真值为-13对应补码10010，则它们的补码直接逐位相加结果为00000对应真值0，结果正确。</li></ul></li><li>补码的特征1： <code>REPRESENTATION(value+1) = REPRESENTATION(value) + REPRESENTATION(1)</code>，其中<code>REPRESENTATION(value)</code>代表数值value对应的码字。<ol><li>如<code>REPRESENTATION(-12) = REPRESENTATION(-13) + REPRESENTATION(1)</code>，其中<code>REPRESENTATION(-12)=10100</code>,<code>REPRESENTATION(-13)=10011</code>,<code>REPRESENTATION(1)=00001</code></li><li>如-1的码字是11111，-2是11110，-3是11101。</li></ol></li><li>补码的特征2：在补码表示中，如果已知一个非零整数A的码字，可以很方便地求得其相应负数-A的码字。口诀是<strong>取反加1</strong>。<ul><li>如-A=-13，对应码字为10011，则A=13对应码字为01101。</li></ul></li></ol></li></ul><hr><h3><span id="2023年3月17日-没看完-书中知识太老了建议看csapp">2023年3月17日 没看完 书中知识太老了，建议看CSAPP</span></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人心得 </tag>
            
            <tag> 书籍 </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始介绍CMake】</title>
      <link href="/posts/d95a6a0e.html"/>
      <url>/posts/d95a6a0e.html</url>
      
        <content type="html"><![CDATA[<h1><span id="对应网课和版权所有链接"></span></h1><h1><span id="cmake">CMake</span></h1><h1><span id="说明">说明</span></h1><p>cmake的定义是什么 ？——-高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了——-CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><p>官 方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p><h1><span id="cmake安装">CMake安装</span></h1><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p><h1><span id="cmake一个helloword">CMake一个HelloWord</span></h1><p>1、步骤一，写一个HelloWord</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">main</span><span class="token expression"><span class="token punctuation">.</span>cpp</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、步骤二，写CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">CMakeLists<span class="token punctuation">.</span>txt</span></span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST <span class="token string">"main.cpp"</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is BINARY dir "</span> $<span class="token punctuation">{</span>HELLO_BINARY_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is SOURCE dir "</span> $<span class="token punctuation">{</span>HELLO_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello $<span class="token punctuation">{</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>3、步骤三、使用cmake，生成makefile文件</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">cmake <span class="token punctuation">.</span>输出：<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># cmake <span class="token punctuation">.</span>CMake <span class="token function">Warning</span> <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> in CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">:</span>  Syntax Warning in cmake code at    <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">/</span>CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">:</span><span class="token number">7</span><span class="token operator">:</span><span class="token number">37</span>  Argument <span class="token operator">not</span> separated from preceding token by whitespace<span class="token punctuation">.</span>This warning is <span class="token keyword">for</span> project developers<span class="token punctuation">.</span>  Use <span class="token operator">-</span>Wno<span class="token operator">-</span>dev to suppress it<span class="token punctuation">.</span><span class="token operator">--</span> The C compiler identification is GNU <span class="token number">10.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">--</span> The CXX compiler identification is GNU <span class="token number">10.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">--</span> Check <span class="token keyword">for</span> working C compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>cc<span class="token operator">--</span> Check <span class="token keyword">for</span> working C compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>cc <span class="token operator">--</span> works<span class="token operator">--</span> Detecting C compiler ABI info<span class="token operator">--</span> Detecting C compiler ABI info <span class="token operator">-</span> done<span class="token operator">--</span> Check <span class="token keyword">for</span> working CXX compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>c<span class="token operator">++</span><span class="token operator">--</span> Check <span class="token keyword">for</span> working CXX compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>c<span class="token operator">++</span> <span class="token operator">--</span> works<span class="token operator">--</span> Detecting CXX compiler ABI info<span class="token operator">--</span> Detecting CXX compiler ABI info <span class="token operator">-</span> done<span class="token operator">--</span> This is BINARY dir <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">--</span> This is SOURCE dir <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">--</span> Configuring done<span class="token operator">--</span> Generating done<span class="token operator">--</span> Build files have been written to<span class="token operator">:</span> <span class="token operator">/</span>root<span class="token operator">/</span>cmake</code></pre><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br>现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">root@localhost cmake<span class="token punctuation">]</span># makeScanning dependencies of target hello<span class="token punctuation">[</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">]</span> Building CXX object CMakeFiles<span class="token operator">/</span>hello<span class="token punctuation">.</span>dir<span class="token operator">/</span>main<span class="token punctuation">.</span>cpp<span class="token punctuation">.</span>oLinking CXX executable hello<span class="token punctuation">[</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">]</span> Built target hello</code></pre><p>5、最终生成了Hello的可执行程序</p><h1><span id="cmake一个helloword-的语法介绍">CMake一个HelloWord-的语法介绍</span></h1><h2><span id="project关键字">PROJECT关键字</span></h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</projectname></p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</projectname></p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2><span id="set关键字">SET关键字</span></h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2><span id="message关键字">MESSAGE关键字</span></h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2><span id="add_executable关键字">ADD_EXECUTABLE关键字</span></h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1><span id="语法的基本原则">语法的基本原则</span></h1><ul><li>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>  就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2><span id="语法注意事项">语法注意事项</span></h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1><span id="内部构建和外部构建">内部构建和外部构建</span></h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2><span id="外部构建方式举例">外部构建方式举例</span></h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//例子目录，CMakeLists.txt和上面例子一致</span><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># pwd<span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># lltotal <span class="token number">8</span><span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root <span class="token number">198</span> Dec <span class="token number">28</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span> CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root  <span class="token number">76</span> Dec <span class="token number">28</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">18</span> main<span class="token punctuation">.</span>cpp</code></pre><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1><span id="让hello-world看起来更像一个工程">让Hello World看起来更像一个工程</span></h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2><span id="将目标文件放入构建目录的-bin-子目录">将目标文件放入构建目录的 bin 子目录</span></h2><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp</code></pre><p>外层CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span></code></pre><p>src下的CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span></code></pre><h3><span id="add_subdirectory-指令">ADD_SUBDIRECTORY 指令</span></h3><p><code>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></p><ul><li>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</li><li><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的example</li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>  将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>  如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3><span id="更改二进制的保存路径">更改二进制的保存路径</span></h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p><code>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</code><br><code>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</code></p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1><span id="安装">安装</span></h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：<code>make install DESTDIR=/tmp/test</code></li><li>稍微复杂一点可以这样指定目录：<code>./configure –prefix=/usr</code></li></ul></li></ul><h2><span id="如何安装helloword">如何安装HelloWord</span></h2><p><strong>作用：通过运行命令行，使得指定文件安装到指定区域上。</strong></p><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 目录树结构</span><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt├── COPYRIGHT├── doc│   └── hello<span class="token punctuation">.</span>txt├── README├── runhello<span class="token punctuation">.</span>sh└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span class="token number">3</span> directories<span class="token punctuation">,</span> <span class="token number">7</span> files</code></pre><h3><span id="安装文件copyright和readme">安装文件COPYRIGHT和README</span></h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<destination 定义的路径></destination></p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3><span id="安装脚本runhellosh">安装脚本runhello.sh</span></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3><span id="安装-doc-中的-hellotxt">安装 doc 中的 hello.txt</span></h3><ul><li>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</li><li><p>二、 <strong>(该方法目前我测试有bug)</strong> 是直接在工程目录通过</p><p>   INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3><span id="安装过程">安装过程</span></h3><p>cmake ..</p><p>make</p><p>make install</p><h1><span id="静态库和动态库的构建">静态库和动态库的构建</span></h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2><span id="构建实例">构建实例</span></h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── lib    ├── CMakeLists<span class="token punctuation">.</span>txt    ├── hello<span class="token punctuation">.</span>cpp    └── hello<span class="token punctuation">.</span>h</code></pre><p>hello.h中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>hello.cpp中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>项目中的cmake内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3><span id="add_library">ADD_LIBRARY</span></h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3><span id="同时构建静态和动态库">同时构建静态和动态库</span></h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3><span id="set_target_properties">SET_TARGET_PROPERTIES</span></h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//对hello_static的重名为hello</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3><span id="动态库的版本号">动态库的版本号</span></h3><p>一般动态库都有一个版本号的关联</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-&gt;</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-&gt;</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3><span id="安装共享库和头文件">安装共享库和头文件</span></h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</prefix></p><p>将 hello.h 安装到<prefix>/include/hello 目录</prefix></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//文件放到该目录下</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello<span class="token punctuation">.</span>h DESTINATION include<span class="token operator">/</span>hello<span class="token punctuation">)</span><span class="token comment">//二进制，静态库，动态库安装都用TARGETS</span><span class="token comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3><span id="使用外部共享库和头文件">使用外部共享库和头文件</span></h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv cmake3<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp</code></pre><p>main.cpp</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3><span id="解决make后头文件找不到的问题">解决：make后头文件找不到的问题</span></h3><p>PS：include <hello hello.h>  这样include是可以，这么做的话，就没啥好讲的了</hello></p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3><span id="解决找到引用的函数问题">解决：找到引用的函数问题</span></h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv bin<span class="token punctuation">]</span># ldd main linux<span class="token operator">-</span>vdso<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span><span class="token number">0x00007ffedfda4000</span><span class="token punctuation">)</span>libhello<span class="token punctuation">.</span>so <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libhello<span class="token punctuation">.</span><span class="token function">so</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0d8f000</span><span class="token punctuation">)</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0874000</span><span class="token punctuation">)</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0572000</span><span class="token punctuation">)</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c035c000</span><span class="token punctuation">)</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41bff8e000</span><span class="token punctuation">)</span><span class="token operator">/</span>lib64<span class="token operator">/</span>ld<span class="token operator">-</span>linux<span class="token operator">-</span>x86<span class="token operator">-</span><span class="token number">64.</span>so<span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0b7c000</span><span class="token punctuation">)</span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3><span id="特殊的环境变量-cmake_include_path-和-cmake_library_path">特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</span></h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p><h1><span id="本人所有视频和笔记都是免费分享给大家的制作视频和笔记要花费大量的时间成本">本⼈所有视频和笔记都是免费分享给⼤家的，制作视频和笔记要花费⼤量的时间成本</span></h1><p>我也有⽼婆和孩⼦要养，恳求各位观众⽼爷们有经济实⼒的稍微打赏⼀下⼩弟，但不强求，再⼀次感谢。<br>您的打赏，会让我今后有更⼤的动⼒，做出更优质的视频，感谢⼤家的⽀持</p><p><img src="CMake%204f0e9a3fcf9949adab4540191610cf3e/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数字设计与计算机体系结构】第二版中译个人心得</title>
      <link href="/posts/496fb1b3.html"/>
      <url>/posts/496fb1b3.html</url>
      
        <content type="html"><![CDATA[<h2><span id="175cmos-书p19">1.7.5CMOS 书P19</span></h2><ul><li>CMOS比较擅长构成的门电路是<strong>非门、与非门、或非门、传输门</strong>。</li><li>像与门就用与非门+非门组成。</li></ul><h2><span id="164直流电压传输特性-书p15">1.6.4直流电压传输特性 书P15</span></h2><ul><li>书中谈到选择逻辑电平的合理方法是选择在传输特征曲线斜率$\frac{dV(Y)}{dV(A)}=-1$的位置，对应<strong>图1-25</strong>中的$V_{IL}$和$V_{IH}$。这两个位置被称为单位增益点。在单位增益点选择逻辑电平可以最大化噪声容限。</li><li>个人理解：选择这两个点后，性质与 <strong>图1-25 a)</strong> 的反相器理想曲线会很相似。</li></ul><h2><span id="281复用器">2.8.1复用器</span></h2><ol><li>书P48<ul><li>书中谈到，一个$2^N$个输入的复用器可以通过将合适的输入连接到0或者1的方法来实现任何$N$输入逻辑函数。</li><li>个人理解：$N$输入有$2^N$种可能的组成结果。</li></ul></li></ol><h2><span id="29时序">2.9时序</span></h2><h3><span id="291传播延迟和最小延迟-书p51">2.9.1传播延迟和最小延迟 书P51</span></h3><ul><li>传播延迟$t_{pd}$:<ul><li>定义1：当输入改变直到一个或多个输出达到它们的<strong>最终值</strong>所经历的最长时间。</li><li>定义2：一个信号从输入到输出的 <strong>关键路径(critical path)</strong> 长度。</li></ul></li><li>最小延迟$t_{cd}$:<ul><li>定义1：当一个输入发生变化直到任何一个输出 <strong>开始改变</strong> 的最短时间。</li><li>定义2: 一个信号从输入到输出的 <strong>最短路径(short path)</strong> 长度。</li></ul></li><li>最短控制 - 输出延迟：控制信号的输入到最终输出的时间最小值。当 <strong>数据输入在控制输入前</strong> 到达时，倾向使用该策略。<ul><li>个人理解：由于数据信号先达到，故需要想法设法减少控制信号达到的时间。</li></ul></li><li>最短数据 - 输出延迟：数据信号的输入到最终输出的时间最小值。当 <strong>控制输入在数据输入前</strong> 到达时，倾向使用该策略。</li></ul><h2><span id="3时序逻辑设计">3时序逻辑设计</span></h2><h3><span id="32锁存器和触发器-书p61">3.2锁存器和触发器 书P61</span></h3><ul><li>发展历史<ol><li>交叉耦合的反相器对。特点：有记忆功能，但是没有输入。</li><li>SR锁存器。特点：是交叉耦合的或非门对；当S=R=1时会产生两个输出为0的混乱电路响应；S和R混淆了时间和内容。</li><li>D锁存器。特点：在SR锁存器的基础上将输入分为数据输入D和时钟输入CLK；避免了S和R同时为1的情况；电平敏感。</li><li>D触发器。特点：使用两个D锁存器；在时钟CLK上升沿将数据输入D复制到输出Q。</li><li>寄存器：由共享一个公共$CLK$的一排N个触发器组成。<h3><span id="例34竞争条件-书p68">例3.4竞争条件 书P68</span></h3></li></ol></li><li>过程分析：假设初始状态$CLK=D=1$，通过反相器需要的时间相较与门和或门要长很多。<ol><li>在初始状态$CLK=D=1$下，$Q_{prev}=Q=1$。</li><li>当$CLK=0$时，$N1=0$，此时由于反相器速度很慢，$N2$仍为$0$，故得到$Q=0，Q_{prev}=0$。</li><li>等到$\overline{CLK}=1$时，由于$Q_{prev}=0$，则此时$N2=0$，输出$Q=0$，而不会保持预期值1了。<h3><span id="建立时间约束最大延迟约束和保持时间约束最小延迟约束书p84">建立时间约束（最大延迟约束）和保持时间约束（最小延迟约束）书P84</span></h3></li></ol></li><li>关键是理解两者的思想内涵。注意书中的分析都是基于<strong>R2</strong>展开的；CLK上升沿到达<strong>R1</strong>后，才会开始引起后续的一系列变化。<ol><li><strong>建立时间约束</strong>是为了满足R2的建立时间，即D2必须在不迟于<strong>下一个</strong>时钟沿之前的建立时间稳定。因为它限制了组合逻辑的最大延迟，故又称最大延迟约束。</li><li><strong>保持时间约束</strong>是为了满足R2的保持时间，即输入D2必须保持不变直到<strong>本次</strong>时钟沿满足$t_{hold}$的要求。因为它限制了组合逻辑的最小延迟，故又称最小延迟约束。</li><li>引入时钟偏移$ t_{skew} $后，务必抓住前面两点理解。要尽量减少时钟偏移。</li><li>$t_{cd}$和$t_{pd}$是设计师可以控制的变量，一般是通过增减组合路径上的门电路数确定。其他变量一般由制造商确定。<h3><span id="分辨时间-书86">分辨时间 书86</span></h3></li></ol></li><li>书中的公式$P(t_{res}&gt;t)=\frac{T_{0}}{T_{c}}e^{-\frac{t}{\tau}}$<br>分析：$T_{c}$为时钟周期，$\tau$和$T_{0}$由触发器的属性决定。一般来说取$t = t_{pcq}$时，该公式的概率将达到一个很高的值。</li><li>分辨时间是指输出从亚稳态到稳态的时间。</li><li>书P90的公式（3-25）推导：$P(t_{res}&gt;t)=\frac{T_{0}}{T_{c}}e^{-\frac{t}{\tau}}$将$t = T_{c}-t_{setup}$代入即可。</li></ul><h2><span id="5-数字模块">5. 数字模块</span></h2><h3><span id="先进进位加法器-书p147">先进进位加法器 书P147</span></h3><ul><li>超前进位加法器的思想是<strong>并行计算进位</strong>，以缩短关键路径。<br>主要公式：进位信号<script type="math/tex">C_i = A_iB_i + B_iC_{i-1} + A_iC_{i-1} = A_iB_i + (A_i+B_i)C_{i-1}=G_i+P_iC_{i-1}</script><h3><span id="556-只读存储器-书p165">5.5.6 只读存储器 书P165</span></h3></li><li>书中原理：为了读ROM位单元，<strong>位线</strong>被缓慢的拉至高电平1。随后打开<strong>字线</strong>（即赋值为1，这样会打开NMOS），如果晶体管存在，则位线会接地变为低电平0；如果晶体管不存在，则仍然保持高电平1。</li><li>一个$2^N字\times M位$的存储器可以实现任何$N$输入和$M$输出的组合逻辑功能，这种用于执行逻辑的存储阵列称为<strong>查找表(LUT)</strong>。</li><li>这里的<strong>字</strong>仅仅是代表存储器的行，对应的<strong>位</strong>代表列。</li></ul><h2><span id="6-体系结构">6. 体系结构</span></h2><h3><span id="632-i类型指令-书p189">6.3.2 I类型指令 书P189</span></h3><ul><li>为什么补码进行扩展一般是用符号扩展？原因是符号扩展不改变补码的值。例：<pre class="language-none"><code class="language-none">001 符号扩展为 000 001  ——&gt; 原码值为000 001即+1101 符号扩展为 111 101  ——&gt; 原码值为100 011即-3</code></pre></li></ul><h2><span id="7-微体系结构">7. 微体系结构</span></h2><h3><span id="711-体系结构状态和指令集-newbing">7.1.1 体系结构状态和指令集 newbing</span></h3><ul><li>体系结构状态是指计算机体系结构中的<strong>寄存器和内存中的数据</strong>的集合。它反映了计算机在某一时刻的运行状态。不同的指令会改变体系结构状态，例如读写寄存器或内存。体系结构状态与微体系结构状态不同，微体系结构状态是指微处理器内部的数据，例如流水线、缓存、预测等。</li><li>体系结构寄存器是指在指令集中可以使用，提供给程序员使用的寄存器。它们反映了体系结构状态，也就是计算机的运行状态；非体系结构寄存器是指不需要程序员了解，对他们而言是透明的，指令不能直接对这些寄存器使用的寄存器。它们是CPU内部的物理寄存器，用来提高处理器的指令级并行的能力。例如，流水线、缓存、预测等都涉及非体系结构寄存器2。<h3><span id="733-更多指令-书p239">7.3.3 更多指令 书P239</span></h3></li><li>扩展主译码器真值表中各个控制信号的含义：<ul><li>RegWrite：是否写寄存器文件。</li><li>RegDst：选择目的寄存器是Instr[20:16]还是Instr[15:11]。</li><li>ALUSrc：选择ALU的输入之一是来自立即数扩展还是寄存器文件。</li><li>Branch：是否为有条件分支指令。</li><li>MemWrite：是否向存储器写数据。</li><li>MemtoReg:选择写入寄存器文件的数据是来自ALU结果还是数据存储器。</li><li>ALUOp:选择ALU计算是否涉及加法、减法或者依赖于funct字段。比如lw rt, imm(rs)中，就涉及imm+$rs的加法，故lw的ALUOp为加法字段。</li><li>Jump:是否为无条件跳转指令。<h3><span id="781-深流水线-书p282">7.8.1 深流水线 书P282</span></h3></li></ul></li><li>例7.11 深流水线中， 指令时间$T_{instruction}$=$T_c*CPI$。</li></ul><hr><h3><span id="2023年3月16日-看完-好书">2023年3月16日 看完 好书</span></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人心得 </tag>
            
            <tag> 数字设计与计算机体系结构 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GNU/Linux】Linux入门教程</title>
      <link href="/posts/7eb74ede.html"/>
      <url>/posts/7eb74ede.html</url>
      
        <content type="html"><![CDATA[<h2><span id="1终端重要命令">1.终端重要命令</span></h2><ul><li><h3><span id="查找操作">查找操作</span></h3><ul><li><code>find {{path}} -name {{file-name}}</code> - 在<code>path</code>目录下查找名为<code>file-name</code>的文件。<ul><li><code>find ./ -name "*.[ch]"</code> - 查找当前目录下的.c和.h文件</li></ul></li><li><code>grep "int i" {{file-name}}</code> - 查找文件<code>file</code>内<code>int i</code>的位置。<ul><li><strong>note</strong>:这里没有限定单词边界。</li></ul></li><li><code>grep "\bint i\b" {{file-name}}</code> - 查找文件<code>file</code>内<code>int i</code>的位置。注意这里<ul><li><code>\b \b</code> - 单词边界。</li><li><strong>note</strong>:这里限定单词边界。</li></ul></li><li><code>find ./ -name "*.[ch]" | xargs grep "#include" | sort | uniq</code> - 列出<code>.c</code>和<code>.h</code>文件中所有被包含过的头文件。 <strong>eXtended ARGumentS:xargs</strong> - <code>sort</code>是排序，<code>uniq</code>是去除相同的。<ul><li><strong>推广：可以据此查找任意文件中的任意一段代码。</strong></li></ul></li><li><code>grep -r 'hello' ./</code>递归地在当前目录下查找’hello’,若查找内容中有同类型引号，则在前加<code>\</code></li><li><code>find ./ -name 'dir'</code>在当前目录下查找名字为<code>dir</code>的目录。<code>./</code>代表当前目录。</li><li><code>find ./ -name '*.*' | xargs grep 'hello' | sort | uniq</code>在当前目录下查找所有文件中的<code>hello</code>。</li><li>通配符<ul><li><code>*</code>为任意长度的任意字符串</li><li><code>?</code>为任意一个字符</li><li><code>[]</code>为集合中的任意一个字符</li><li><code>{}</code>括号拓展。例如<code>echo Hello-{a,bb,cc}-{1,2}</code></li></ul></li></ul></li><li><h3><span id="统计操作">统计操作</span></h3><ul><li><code>df -h</code> - 查看磁盘分区的使用情况。<strong>df:disk free</strong>。</li><li><code>wc {{file}}</code> - 统计文件的行数/单词数/字符数<ul><li><code>wc -l {{file}}</code> - 统计文件的行数</li><li><code>wc -w {{file}}</code> - 统计文件的单词数</li><li><code>wc -c {{file}}</code> - 统计文件的字符数</li></ul></li><li><code>strace {{program}}</code> - system call trace, 记录程序运行过程中的系统调用信息<ul><li>如<code>strace ls</code>。查看<code>ls</code>命令的系统调用信息。</li><li>通过观察程序运行过程中发生的系统调用，可以大致了解程序关键行为。</li></ul></li><li><code>ltrace {{program}}</code> - library call trace, 记录程序运行过程中的库调用信息</li></ul></li><li><h3><span id="文件操作">文件操作</span></h3><ul><li><code>sudo apt-get install {{tool-name}}</code> - 一键下载安装新工具</li><li><code>wget {{http://www.xxx.com//abc.zip}}</code> - 网站下载文件</li><li><code>iconv -f uft-8 -t gbk {{file-name}}</code> - 将文件file的格式进行转换，例子中是从<code>uft-8</code>转换到<code>gbk</code></li><li>比较两个文件是否完全相同<ul><li>文本文件的比较: <code>vimdiff {{file1}} {{file2}}</code></li><li>非文本文件的比较: <code>diff {{file1}} {{file2}}</code></li><li>很大的文件: <code>md5sum {{file1}} {{file2}}</code> - 两个文件的md5码不一样，就肯定不是同一个文件。</li></ul></li><li><code>rm -rf ./*</code>删除当前目录下的所有文件。</li><li><code>cat {{file}}</code>打印文件中的内容。</li><li><code>echo "" &gt; {{file}}</code>清空文件。</li><li><code>echo "abc" &gt;&gt; {{file}}</code>将”abc”追加到文件内。</li><li><code>touch {{file}}</code>创建文件。</li><li><code>tree</code>显示当前目录下的目录树。</li><li><code>rm ./*.txt</code>删除当前目录下的所有.txt文件。</li><li><code>a,b y *</code>复制a到b行的内容到系统剪切板<ul><li><code>*</code>为系统剪切板，<code>y</code>为复制</li></ul></li><li><code>chmod 777</code>后接对应操作获取文件权限。</li><li><code>chmod -R 777 *</code>对当前目录下的所有文件获取权限。去掉<code>-R</code>就只限于当前目录。</li><li><code>tar -xzvf 压缩文件名.tar.gz</code>解压.tar.gz文件。</li><li><code>tar -xvf 压缩文件名.tar.bz2</code>解压.tar.bz文件。</li><li><code>cat 压缩文件名.tar.bz2.parta* &gt; 压缩文件名.tar.bz2</code>将parta*分离压缩文件合并成完整的压缩文件。</li><li><code>cp -r dirA dirB</code>复制目录A到目录B</li></ul></li><li><h3><span id="任务管理">任务管理</span></h3><ul><li><strong>推荐方法</strong>：<code>gnome-system-monitor</code> - 打开任务栏图形界面。</li></ul></li><li><h3><span id="命令管理">命令管理</span></h3><ul><li><code>history</code> - 查看历史命令</li><li><code>!{{number}}</code> - 执行历史命令中的第<code>number</code>条命令</li><li><code>!!</code> - 执行上一条命令</li><li><code>!{{string}}</code> - 执行最近的以<code>string</code>开头的命令</li><li><code>!{{string}}:p</code> - 打印最近的以<code>string</code>开头的命令，但不执行</li><li><code>!{{string}}:s/{{old}}/{{new}}</code> - 执行最近的以<code>string</code>开头的命令，将其中的<code>old</code>替换为<code>new</code></li><li><code>!{{string}}:gs/{{old}}/{{new}}</code> - 执行最近的以<code>string</code>开头的命令，将其中的<code>old</code>全部替换为<code>new</code></li><li><code>!{{number}}:p</code> - 打印历史命令中的第<code>number</code>条命令，但不执行</li><li><code>!{{number}}:s/{{old}}/{{new}}</code> - 执行历史命令中的第<code>number</code>条命令，将其中的<code>old</code>替换为<code>new</code></li><li><code>!{{number}}:gs/{{old}}/{{new}}</code> - 执行历史命令中的第<code>number</code>条命令，将其中的<code>old</code>全部替换为<code>new</code></li></ul></li></ul><h2><span id="2sh文件重要命令基本所有操作与终端一致">2.<code>.sh</code>文件重要命令（基本所有操作与终端一致）</span></h2><ul><li><h3><span id="脚本指定">脚本指定</span></h3><ul><li><code>#!/bin/bash</code> - 指定脚本解释器为bash</li></ul></li><li><h3><span id="变量更改">变量更改</span></h3><ul><li><code>export {{variable}}={{value}}</code> - 将变量<code>variable</code>的值设置为<code>value</code><ul><li>echo  - 打印变量<code>variable</code>的值</li></ul></li><li><code>export {{variable}}="${{variable}}:=/usr/local}"</code> - 如果变量<code>variable</code>未定义，则将其值设置为<code>/usr/local</code><ul><li>echo  - 打印变量<code>variable</code>的值</li></ul></li><li><code>expr ${{variable}} + 1</code> - 将变量的值加1</li><li>x分别取a到z的值，然后执行do中的语句。<pre class="language-none"><code class="language-none">for x in {a..z}do    echo $xdone</code></pre></li></ul></li><li><h3><span id="参数获取">参数获取</span></h3><ul><li><code>$1</code>获取第一个参数</li><li><code>$2</code>获取第二个参数</li><li><code>$#</code>获取参数个数</li><li><code>$@</code>获取所有参数</li><li><code>$0</code>获取脚本名称</li><li><code>$?</code>获取上一条命令的返回值</li><li>$$$$获取当前进程的进程号</li><li><code>$!</code>获取上一条命令的进程号</li></ul></li><li><h3><span id="函数调用">函数调用</span></h3></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【旅游】重庆旅游攻略</title>
      <link href="/posts/314c5eec.html"/>
      <url>/posts/314c5eec.html</url>
      
        <content type="html"><![CDATA[<h2><span id="重庆旅游202326-2023210元宵后">重庆旅游（2023.2.6 - 2023.2.10）（元宵后）</span></h2><h3><span id="民宿选择">民宿选择</span></h3><p>民宿是在<strong>途家民宿</strong>APP上找的，位置在观音桥。<br><img src="/img/重庆旅游攻略/民宿的落地窗.jpg" alt="民宿窗外"><br>相较解放碑，观音桥附近的民宿性价比更高，小红书上说这里是重庆本地人的聚集地。<br>附近有观音桥商圈，公共交通（地铁）也比较附近。有个<strong>红旗沟长途汽车站</strong>可以通往郊区的景点，比如统景温泉（<strong>房东说的</strong>），不过我们没有去郊区玩。</p><h3><span id="推荐美食">推荐美食</span></h3><ul><li>观音桥<ul><li>观音桥的<strong>鹞子丘眼镜火锅</strong>，非常好吃！我两连续吃了三天！<br><img src="/img/重庆旅游攻略/眼镜火锅.jpg" width="30%" height="30%" alt="眼镜火锅"> </li><li>观音桥的<strong>小弟面馆</strong>，挨着鹞子丘眼镜火锅，面馆不大，吃的本地人很多，应该是正宗的重庆面馆。不过我两感觉正宗重庆小面的味道也一般般。<br><img src="/img/重庆旅游攻略/小弟面馆.jpg" width="30%" height="30%" alt="小弟面馆"><br><img src="/img/重庆旅游攻略/小弟面馆的重庆小面.jpg" width="30%" height="30%" alt="小弟面馆的重庆小面"> </li></ul></li><li>解放碑<ul><li>解放碑的<strong>八一好吃街外</strong>的甜筒，忘记啥名字了。我两炫了两根，一根原味一根巧克力。<br><img src="/img/重庆旅游攻略/甜筒.jpg" width="30%" height="30%" alt="甜筒"> </li><li>解放碑的<strong>好又来酸辣粉</strong>，10元一碗酸辣粉，特别好吃！</li><li><strong>陈昌银麻花</strong>也可以。不过淘宝上有卖。</li></ul></li></ul><h3><span id="推荐景点">推荐景点</span></h3><ul><li>沙坪坝<ul><li><strong>融汇温泉</strong>力荐！200左右一人（包一餐）。我两在里面吃的中餐，味道还不错。<br>温泉种类很多，我们去的时候人不算多，温泉水质比较好。里面的环境和配套设施也非常完善。<br>服务特别棒！我两刚下车，门口就有服务员给我们开车门，然后领路！<br>2楼有餐厅和配套休息室！我两中午到的，就先在2楼的休息室睡了一觉，很舒服！</li></ul></li><li>解放碑商圈<ul><li>即八一好吃街附近。里面吃的多，玩的也有一些。老婆在一个商城里面玩了好一阵子，开心。<br><img src="/img/重庆旅游攻略/树.jpg" width="30%" height="30%" alt="拍的树"><br><img src="/img/重庆旅游攻略/人民解放碑.jpg" width="30%" height="30%" alt="人民解放碑"><br><img src="/img/重庆旅游攻略/八一好吃街.jpg" width="30%" height="30%" alt="八一好吃街"> </li></ul></li><li>观音桥商圈<br>和解放碑商圈比较类似。不过外地人不来也挺可惜的。里面的价格相较解放碑商圈也便宜些。<br>里面有两个仿冒茶颜悦色的奶茶品牌，一个叫霸王茶姬，一个叫初茶花月。初茶花月的logo是真的巨丑，不过里面喝的仿·幽兰拿铁的味道还不错。</li></ul><h3><span id="避坑">避坑</span></h3><ul><li>洪崖洞<br><strong>洪崖洞千万不要去</strong>，就是一坨shit，里面没什么玩的，还人挤人！在网上看看图片就好！下面是我两在洪崖洞附近拍的图。<br><strong>cover的图就是洪崖洞</strong>，在里面玩可拍不出这种效果。<br><img src="/img/重庆旅游攻略/重庆大剧院.jpg" width="30%" height="30%" alt="重庆大剧院"><br><img src="/img/重庆旅游攻略/洪崖洞灯笼.jpg" width="30%" height="30%" alt="洪崖洞灯笼"> </li></ul><h3><span id="房东推荐的攻略">房东推荐的攻略</span></h3><p>放在这篇博客里面啦！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wzm </tag>
            
            <tag> tyh </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vivado】ROM IP核的使用</title>
      <link href="/posts/ab5b7cc3.html"/>
      <url>/posts/ab5b7cc3.html</url>
      
        <content type="html"><![CDATA[<ul><li><h3><span id="rom-ip核的创建方法"><strong>ROM IP核的创建方法</strong></span></h3><img src="https://foruda.gitee.com/images/1675436593019752405/109dae0b_6531589.png" alt="1" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703461077393/b393cba0_6531589.png" alt="2" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703187128425/c590353a_6531589.png" alt="3" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703029907655/40f1f38a_6531589.png" alt="4" title="屏幕截图"><br>然后点击确定，就能生成一个ROM IP核。</li></ul><hr><ul><li><h3><span id="rom-ip核的调用方法"><strong>ROM IP核的调用方法</strong></span></h3><img src="https://foruda.gitee.com/images/1675436918059218885/ace5fdad_6531589.png" alt="1" title="屏幕截图"><br>由于ROM IP核是在 _上升沿_ 读数据，所以如果要将从ROM读的数据写入到其他地方的话，可以在时钟的 _下降沿_ 写数据，具体操作如下：<pre class="language-none"><code class="language-none">// clk下降沿进行address自增，下一个上升沿在rom进行读数据always @(negedge clk) begin // rom是clk上升沿读，所以这里一定要是下降沿！    if (rst) begin // 同步复位        addra_7bit &lt;= 0;        in &lt;= 0;    end    else begin        // 将上个上升沿读的数据写入        in[addra_7bit] &lt;= wave_douta;         if(addra_7bit &lt; (len-1)) begin            addra_7bit &lt;= addra_7bit + 1'b1;        end        else begin            addra_7bit &lt;= 0;        end    endendrom_wave_64w_128d rom_wave (    // 上升沿读数据    .clka(clk),      .addra(addra_7bit),      .douta(wave_douta) ![输入图片说明](https://foruda.gitee.com/images/1675437561499899947/cd9436de_6531589.png "屏幕截图"));</code></pre></li></ul><hr><ul><li><h3><span id="rom-ip核的注意事项"><strong>ROM IP核的注意事项</strong></span></h3></li></ul><ol><li>IP核设置的width可以比实际coe内的数据的width更宽，但是depth必须和实际coe文件内的数据一致。</li><li>当更新coe文件后，必须在IP核配置界面重新LOAD FILE，如下图：<br><img src="https://foruda.gitee.com/images/1675437570773333850/2a2dd185_6531589.png" alt="2" title="屏幕截图"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado </tag>
            
            <tag> IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VMware】VMware-tools一条龙解决方案</title>
      <link href="/posts/6820c6bc.html"/>
      <url>/posts/6820c6bc.html</url>
      
        <content type="html"><![CDATA[<h4><span id="1-vmware-tools工具安装">1. VMware Tools工具安装</span></h4><ol><li><p>右键虚拟机$\rightarrow$安装VMware Tools</p></li><li><p>找到VMware Tools安装压缩包的位置</p><pre class="language-none"><code class="language-none">$cd /mnt/$sudo find / -name VMware*</code></pre></li><li><p>找到位置后进入目录，解压到/opt/目录（其他目录也可），比如：</p></li></ol><pre class="language-none"><code class="language-none">/media/username$ sudo tar -xzvf VMwareTools-10.2.0-7259539.tar.gz -C /opt/</code></pre><ol><li><p>在/opt下安装VMware Tools</p><pre class="language-none"><code class="language-none">/opt$ sudo ./vmware-install.pl</code></pre><p>安装过程一直默认即可</p></li><li><p>记得<strong>启用共享文件夹</strong>。</p></li></ol><h4><span id="2-vmware与windows实现文件拖拽与复制">2. VMware与Windows实现文件拖拽与复制</span></h4><p>在虚拟机的命令行输入以下命令：<br></p><pre class="language-none"><code class="language-none">$sudo apt-get autoremove open-vm-tools$sudo apt-get install open-vm-tools-desktop$sudo reboot</code></pre><br>并且<strong>打开共享文件夹</strong>即可。<p></p><h4><span id="3-解决共享文件夹消失">3. 解决共享文件夹消失</span></h4><pre class="language-none"><code class="language-none">// 在虚拟机Ubutnu /mnt/hgfs文件夹下找不到共享文件夹或者在Ubuntu终端中运行命令行 ：$vmware-hgfsclient    // 查看开启的共享文件夹$sudo vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GNU/Linux】Unified Format</title>
      <link href="/posts/6393c1cf.html"/>
      <url>/posts/6393c1cf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="该格式用来对比修改前和修改后的两个文件的差异">该格式用来对比修改前和修改后的两个文件的差异</span></h2><p><img src="https://foruda.gitee.com/images/1676295492065282810/c43f014d_6531589.png" alt="1" title="1.png"><br>可以看出图中的两个文件 _lao_ 和  _tzu_ 中的字段有一些差异。<br>使用命令<code>diff -u lao tzu</code>后输出如下图：<br><img src="https://foruda.gitee.com/images/1676295542401435909/f188388c_6531589.png" alt="2" title="2.png"><br>首段的<br></p><pre class="language-none"><code class="language-none">--- lao 2002-02-21 23:30:39.942229878 -0800+++ tzu2002-02-21 23:30:50.442260588 -0800</code></pre><br>代表_lao_文件是<code>-</code>表征，_tzu_文件是<code>+</code>表征。<br><pre class="language-@@" data-language="@@"><div class="caption"><span>-1,7 +1,6 @@```和```@@ -9,3 +8,6 @@```代表该对比段在源文件中的【块起始行，块所占行数】。后面的代码中，如</span></div><code class="language-@@">```-The Way that can be told of is not the eternal Way;-The name that can be named is not the eternal name. The Nameless is the origin of Heaven and Earth;-The Named is the mother of all things.+The named is the mother of all things.</code></pre><br>所示，<code>-</code>代表是_lao_文件中独有的，<code>+</code>代表是_tzu_文件中独有的。没有<code>+</code>或<code>-</code>的字段代表是两个文件共有的。<p></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切的开始</title>
      <link href="/posts/25e1c0d9.html"/>
      <url>/posts/25e1c0d9.html</url>
      
        <content type="html"><![CDATA[<h3><span id="我和我的最爱">我和我的最爱！</span></h3><p><img src="/img/tang/pic1.jpg" width="30%" height="30%" alt="tyh&amp;wzm"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wzm </tag>
            
            <tag> tyh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【git】git部分重要命令</title>
      <link href="/posts/cff33c4a.html"/>
      <url>/posts/cff33c4a.html</url>
      
        <content type="html"><![CDATA[<h2><span id="1-git常用命令">1. git常用命令</span></h2><ul><li><code>git clone &lt;url&gt;</code>: 克隆远程仓库到本地<ul><li><code>git clone --recursive &lt;url&gt;</code>: 克隆远程仓库到本地，包括子模块</li><li><code>vim .gitmodules</code>: 查看子模块信息</li></ul></li><li><code>git init</code>: 初始化本地仓库</li><li><code>git add &lt;file&gt;</code>: 添加文件到暂存区<ul><li><code>git add .</code>: 添加所有文件到暂存区</li></ul></li><li><code>git commit -m &lt;message&gt;</code>: 提交暂存区到本地仓库</li><li><code>git status</code>: 查看本地仓库状态</li><li><code>git log</code>: 查看提交日志</li><li><code>git branch &lt;branch_name&gt;</code>: 创建分支</li><li><code>git checkout &lt;branch_name&gt;</code>: 切换分支</li><li><code>git checkout -b &lt;branch_name&gt;</code>: 创建并切换分支</li><li><code>git branch -d &lt;branch_name&gt;</code>: 删除分支</li><li><code>git branch -a</code>: 查看所有分支</li><li><code>git branch -vv</code>: 查看所有分支与远程分支的连接关系</li><li><code>git merge &lt;branch_name&gt;</code>: 合并分支</li><li><code>git remote</code>: 查看当前连接的远程仓库</li><li><code>git remote -v</code>: 查看当前连接的远程仓库详细信息</li><li><code>git remote add &lt;remote_name&gt; &lt;url&gt;</code>: 添加远程仓库</li><li><code>git remote remove &lt;remote_name&gt;</code>: 删除远程仓库</li><li><code>git remote set-url &lt;remote_name&gt; &lt;url&gt;</code>: 修改远程仓库地址</li><li><code>git remote rename &lt;old_name&gt; &lt;new_name&gt;</code>: 修改远程仓库别名</li><li><code>git fetch &lt;remote_name&gt;</code>: 拉取远程仓库<ul><li><code>git fetch</code>: 拉取当前连接的远程仓库</li><li><strong>note</strong>:<code>git fetch</code>拉取后不会对本地仓库进行改变，如需改变，需要使用<code>git merge</code>或<code>git rebase</code></li></ul></li><li><code>git pull &lt;remote_name&gt; &lt;branch_name&gt;</code>: 拉取远程仓库到本地仓库<ul><li><code>git pull</code>: 拉取当前连接的远程仓库到本地仓库</li><li><strong>note</strong>:<code>git pull</code>会改变本地仓库</li></ul></li><li><code>git push &lt;remote_name&gt; &lt;branch_name&gt;</code>: 推送本地仓库到远程仓库<ul><li><code>git push</code>: 推送当前分支到远程仓库</li></ul></li><li><code>git push &lt;remote_name&gt; &lt;branch_name&gt;:&lt;remote_branch_name&gt;</code>: 推送本地仓库到远程仓库的指定分支</li><li><code>git push &lt;remote_name&gt; --delete &lt;branch_name&gt;</code>: 删除远程仓库的指定分支</li><li><code>git reset --hard &lt;commit_id&gt;</code>: 回退到指定commit版本</li><li><code>git reset --hard HEAD^</code>: 回退到上一个commit版本</li><li><code>git reset --hard HEAD~n</code>: 回退到前n个commit版本</li><li><code>git reset --hard &lt;commit_id&gt;</code>: 回退到指定commit版本`</li><li><code>git tag &lt;tag_name&gt; &lt;commit_id&gt;</code>: 给指定commit打标签</li><li><code>git tag -a &lt;tag_name&gt; -m &lt;message&gt;</code>: 给当前commit打标签</li><li><code>git tag -d &lt;tag_name&gt;</code>: 删除指定标签</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
