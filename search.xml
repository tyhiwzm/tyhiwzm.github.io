<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【计算机系统概论】第二版中译个人心得</title>
      <link href="/posts/3f09c5bf.html"/>
      <url>/posts/3f09c5bf.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人心得 </tag>
            
            <tag> 书籍 </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【从零开始介绍CMake】</title>
      <link href="/posts/d95a6a0e.html"/>
      <url>/posts/d95a6a0e.html</url>
      
        <content type="html"><![CDATA[<h1><span id="对应网课和版权所有链接"></span></h1><h1><span id="cmake">CMake</span></h1><h1><span id="说明">说明</span></h1><p>cmake的定义是什么 ？——-高级编译配置工具</p><p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）这时候神器就出现了——-CMake！</p><p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p><p>官 方网站是 <a href="http://www.cmake.org/">www.cmake.org</a>，可以通过访问官方网站获得更多关于 cmake 的信息</p><p>学习CMake的目的，为将来处理大型的C/C++/JAVA项目做准备</p><h1><span id="cmake安装">CMake安装</span></h1><p>1、绝大多数的linux系统已经安装了CMake</p><p>2、Windows或某些没有安装过的linux系统，去<a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p><h1><span id="cmake一个helloword">CMake一个HelloWord</span></h1><p>1、步骤一，写一个HelloWord</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">main</span><span class="token expression"><span class="token punctuation">.</span>cpp</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span>  <span class="token string">"hello world"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、步骤二，写CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression">CMakeLists<span class="token punctuation">.</span>txt</span></span><span class="token function">PROJECT</span> <span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">SET</span><span class="token punctuation">(</span>SRC_LIST <span class="token string">"main.cpp"</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is BINARY dir "</span> $<span class="token punctuation">{</span>HELLO_BINARY_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">MESSAGE</span><span class="token punctuation">(</span>STATUS <span class="token string">"This is SOURCE dir "</span> $<span class="token punctuation">{</span>HELLO_SOURCE_DIR<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello $<span class="token punctuation">{</span>SRC_LIST<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>3、步骤三、使用cmake，生成makefile文件</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">cmake <span class="token punctuation">.</span>输出：<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># cmake <span class="token punctuation">.</span>CMake <span class="token function">Warning</span> <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> in CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">:</span>  Syntax Warning in cmake code at    <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">/</span>CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">:</span><span class="token number">7</span><span class="token operator">:</span><span class="token number">37</span>  Argument <span class="token operator">not</span> separated from preceding token by whitespace<span class="token punctuation">.</span>This warning is <span class="token keyword">for</span> project developers<span class="token punctuation">.</span>  Use <span class="token operator">-</span>Wno<span class="token operator">-</span>dev to suppress it<span class="token punctuation">.</span><span class="token operator">--</span> The C compiler identification is GNU <span class="token number">10.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">--</span> The CXX compiler identification is GNU <span class="token number">10.2</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">--</span> Check <span class="token keyword">for</span> working C compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>cc<span class="token operator">--</span> Check <span class="token keyword">for</span> working C compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>cc <span class="token operator">--</span> works<span class="token operator">--</span> Detecting C compiler ABI info<span class="token operator">--</span> Detecting C compiler ABI info <span class="token operator">-</span> done<span class="token operator">--</span> Check <span class="token keyword">for</span> working CXX compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>c<span class="token operator">++</span><span class="token operator">--</span> Check <span class="token keyword">for</span> working CXX compiler<span class="token operator">:</span> <span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>c<span class="token operator">++</span> <span class="token operator">--</span> works<span class="token operator">--</span> Detecting CXX compiler ABI info<span class="token operator">--</span> Detecting CXX compiler ABI info <span class="token operator">-</span> done<span class="token operator">--</span> This is BINARY dir <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">--</span> This is SOURCE dir <span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token operator">--</span> Configuring done<span class="token operator">--</span> Generating done<span class="token operator">--</span> Build files have been written to<span class="token operator">:</span> <span class="token operator">/</span>root<span class="token operator">/</span>cmake</code></pre><p>目录下就生成了这些文件-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.<br>现在不需要理会这些文件的作用，以后你也可以不去理会。最关键的是，它自动生成了Makefile.</p><p>4、使用make命令编译</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">root@localhost cmake<span class="token punctuation">]</span># makeScanning dependencies of target hello<span class="token punctuation">[</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">]</span> Building CXX object CMakeFiles<span class="token operator">/</span>hello<span class="token punctuation">.</span>dir<span class="token operator">/</span>main<span class="token punctuation">.</span>cpp<span class="token punctuation">.</span>oLinking CXX executable hello<span class="token punctuation">[</span><span class="token number">100</span><span class="token operator">%</span><span class="token punctuation">]</span> Built target hello</code></pre><p>5、最终生成了Hello的可执行程序</p><h1><span id="cmake一个helloword-的语法介绍">CMake一个HelloWord-的语法介绍</span></h1><h2><span id="project关键字">PROJECT关键字</span></h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p><p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p><p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p><p>该指定隐式定义了两个CMAKE的变量</p><p><projectname>_BINARY_DIR，本例中是 HELLO_BINARY_DIR</projectname></p><p><projectname>_SOURCE_DIR，本例中是 HELLO_SOURCE_DIR</projectname></p><p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p><p>问题：如果改了工程名，这两个变量名也会改变</p><p>解决：又定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p><h2><span id="set关键字">SET关键字</span></h2><p>用来显示的指定变量的</p><p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p><p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p><h2><span id="message关键字">MESSAGE关键字</span></h2><p>向终端输出用户自定义的信息</p><p>主要包含三种信息：</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过。</li><li>SATUS，输出前缀为—的信息。</li><li>FATAL_ERROR，立即终止所有 cmake 过程.</li></ul><h2><span id="add_executable关键字">ADD_EXECUTABLE关键字</span></h2><p>生成可执行文件</p><p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p><p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p><p>上述例子可以简化的写成</p><p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p><p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p><h1><span id="语法的基本原则">语法的基本原则</span></h1><ul><li>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</li><li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p><p>  就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p></li><li><p>指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令</p></li></ul><h2><span id="语法注意事项">语法注意事项</span></h2><ul><li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li><li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li></ul><h1><span id="内部构建和外部构建">内部构建和外部构建</span></h1><ul><li>上述例子就是内部构建，他生产的临时文件特别多，不方便清理</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li></ul><h2><span id="外部构建方式举例">外部构建方式举例</span></h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//例子目录，CMakeLists.txt和上面例子一致</span><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># pwd<span class="token operator">/</span>root<span class="token operator">/</span>cmake<span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># lltotal <span class="token number">8</span><span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root <span class="token number">198</span> Dec <span class="token number">28</span> <span class="token number">20</span><span class="token operator">:</span><span class="token number">59</span> CMakeLists<span class="token punctuation">.</span>txt<span class="token operator">-</span>rw<span class="token operator">-</span>r<span class="token operator">--</span>r<span class="token operator">--</span><span class="token punctuation">.</span> <span class="token number">1</span> root root  <span class="token number">76</span> Dec <span class="token number">28</span> <span class="token number">00</span><span class="token operator">:</span><span class="token number">18</span> main<span class="token punctuation">.</span>cpp</code></pre><p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p><p>2、进入build，运行cmake ..    当然..表示上一级目录，你可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p><p>3、在build目录下，运行make来构建工程</p><p>注意外部构建的两个变量</p><p>1、HELLO_SOURCE_DIR  还是工程路径</p><p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p><h1><span id="让hello-world看起来更像一个工程">让Hello World看起来更像一个工程</span></h1><ul><li>为工程添加一个子目录 src，用来放置工程源代码</li><li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li><li>在工程目录添加文本文件 COPYRIGHT, README</li><li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li><li>将构建后的目标文件放入构建目录的 bin 子目录</li><li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li></ul><h2><span id="将目标文件放入构建目录的-bin-子目录">将目标文件放入构建目录的 bin 子目录</span></h2><p>每个目录下都要有一个CMakeLists.txt说明</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp</code></pre><p>外层CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>src bin<span class="token punctuation">)</span></code></pre><p>src下的CMakeLists.txt</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">ADD_EXECUTABLE</span><span class="token punctuation">(</span>hello main<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span></code></pre><h3><span id="add_subdirectory-指令">ADD_SUBDIRECTORY 指令</span></h3><p><code>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</code></p><ul><li>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</li><li><code>EXCLUDE_FROM_ALL</code>函数是将写的目录从编译中排除，如程序中的example</li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>  将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p><p>  如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p></li></ul><h3><span id="更改二进制的保存路径">更改二进制的保存路径</span></h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p><p><code>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)</code><br><code>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</code></p><p>思考：加载哪个CMakeLists.txt当中</p><p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p><h1><span id="安装">安装</span></h1><ul><li>一种是从代码编译后直接 make install 安装</li><li>一种是打包时的指定 目录安装。<ul><li>简单的可以这样指定目录：<code>make install DESTDIR=/tmp/test</code></li><li>稍微复杂一点可以这样指定目录：<code>./configure –prefix=/usr</code></li></ul></li></ul><h2><span id="如何安装helloword">如何安装HelloWord</span></h2><p><strong>作用：通过运行命令行，使得指定文件安装到指定区域上。</strong></p><p>使用CMAKE一个新的指令：INSTALL</p><p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p><p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 目录树结构</span><span class="token punctuation">[</span>root@localhost cmake<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt├── COPYRIGHT├── doc│   └── hello<span class="token punctuation">.</span>txt├── README├── runhello<span class="token punctuation">.</span>sh└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp<span class="token number">3</span> directories<span class="token punctuation">,</span> <span class="token number">7</span> files</code></pre><h3><span id="安装文件copyright和readme">安装文件COPYRIGHT和README</span></h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p><p>FILES：文件</p><p>DESTINATION：</p><p>1、写绝对路径</p><p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<destination 定义的路径></destination></p><p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p><p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p><h3><span id="安装脚本runhellosh">安装脚本runhello.sh</span></h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p><p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p><p>说明：实际安装到的是 /usr/bin</p><h3><span id="安装-doc-中的-hellotxt">安装 doc 中的 hello.txt</span></h3><ul><li>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</li><li><p>二、 <strong>(该方法目前我测试有bug)</strong> 是直接在工程目录通过</p><p>   INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p></li></ul><p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p><p>注意：abc 和 abc/有很大的区别</p><p>目录名不以/结尾：这个目录将被安装为目标路径下的</p><p>目录名以/结尾：将这个目录中的内容安装到目标路径</p><h3><span id="安装过程">安装过程</span></h3><p>cmake ..</p><p>make</p><p>make install</p><h1><span id="静态库和动态库的构建">静态库和动态库的构建</span></h1><p>任务：</p><p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p><p>２，安装头文件与共享库。</p><p>静态库和动态库的区别</p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li><li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li><li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li></ul><h2><span id="构建实例">构建实例</span></h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@localhost cmake2<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── lib    ├── CMakeLists<span class="token punctuation">.</span>txt    ├── hello<span class="token punctuation">.</span>cpp    └── hello<span class="token punctuation">.</span>h</code></pre><p>hello.h中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">HELLO_H</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">Hello_H</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></code></pre><p>hello.cpp中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"hello.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span><span class="token keyword">void</span> <span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>项目中的cmake内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">PROJECT</span><span class="token punctuation">(</span>HELLO<span class="token punctuation">)</span><span class="token function">ADD_SUBDIRECTORY</span><span class="token punctuation">(</span>lib bin<span class="token punctuation">)</span></code></pre><p>lib中CMakeLists.txt中的内容</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3><span id="add_library">ADD_LIBRARY</span></h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p><ul><li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li><li>SHARED，动态库    STATIC，静态库</li><li>${LIBHELLO_SRC} ：源文件</li></ul><h3><span id="同时构建静态和动态库">同时构建静态和动态库</span></h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">// 修改静态库的名字，这样是可以的，但是我们往往希望他们的名字是相同的，只是后缀不同而已</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3><span id="set_target_properties">SET_TARGET_PROPERTIES</span></h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p><p>同时构建静态和动态库</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">SET</span><span class="token punctuation">(</span>LIBHELLO_SRC hello<span class="token punctuation">.</span>cpp<span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello_static STATIC $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment">//对hello_static的重名为hello</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">ADD_LIBRARY</span><span class="token punctuation">(</span>hello SHARED $<span class="token punctuation">{</span>LIBHELLO_SRC<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES  OUTPUT_NAME <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token function">SET_TARGET_PROPERTIES</span><span class="token punctuation">(</span>hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="token number">1</span><span class="token punctuation">)</span></code></pre><h3><span id="动态库的版本号">动态库的版本号</span></h3><p>一般动态库都有一个版本号的关联</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp">libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span>libhello<span class="token punctuation">.</span>so <span class="token operator">-&gt;</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-&gt;</span>libhello<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1.2</span></code></pre><p>CMakeLists.txt 插入如下</p><p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p><p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p><h3><span id="安装共享库和头文件">安装共享库和头文件</span></h3><p>本例中我们将 hello 的共享库安装到<prefix>/lib目录，</prefix></p><p>将 hello.h 安装到<prefix>/include/hello 目录</prefix></p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//文件放到该目录下</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>FILES hello<span class="token punctuation">.</span>h DESTINATION include<span class="token operator">/</span>hello<span class="token punctuation">)</span><span class="token comment">//二进制，静态库，动态库安装都用TARGETS</span><span class="token comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><span class="token function">INSTALL</span><span class="token punctuation">(</span>TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib<span class="token punctuation">)</span></code></pre><p>注意：</p><p>安装的时候，指定一下路径，放到系统下</p><p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p><h3><span id="使用外部共享库和头文件">使用外部共享库和头文件</span></h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv cmake3<span class="token punctuation">]</span># tree<span class="token punctuation">.</span>├── build├── CMakeLists<span class="token punctuation">.</span>txt└── src    ├── CMakeLists<span class="token punctuation">.</span>txt    └── main<span class="token punctuation">.</span>cpp</code></pre><p>main.cpp</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;hello.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">HelloFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3><span id="解决make后头文件找不到的问题">解决：make后头文件找不到的问题</span></h3><p>PS：include <hello hello.h>  这样include是可以，这么做的话，就没啥好讲的了</hello></p><p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p><p>在CMakeLists.txt中加入头文件搜索路径</p><p>INCLUDE_DIRECTORIES(/usr/include/hello)</p><p>感谢：</p><p>网友：zcc720的提醒</p><h3><span id="解决找到引用的函数问题">解决：找到引用的函数问题</span></h3><p>报错信息：undefined reference to `HelloFunc()’</p><p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p><p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p><p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p><p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字就行了。</p><p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p><p>查看main的链接情况</p><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">[</span>root@MiWiFi<span class="token operator">-</span>R4CM<span class="token operator">-</span>srv bin<span class="token punctuation">]</span># ldd main linux<span class="token operator">-</span>vdso<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token punctuation">(</span><span class="token number">0x00007ffedfda4000</span><span class="token punctuation">)</span>libhello<span class="token punctuation">.</span>so <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libhello<span class="token punctuation">.</span><span class="token function">so</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0d8f000</span><span class="token punctuation">)</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libstdc<span class="token operator">++</span><span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0874000</span><span class="token punctuation">)</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libm<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0572000</span><span class="token punctuation">)</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libgcc_s<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c035c000</span><span class="token punctuation">)</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token operator">/</span>lib64<span class="token operator">/</span>libc<span class="token punctuation">.</span>so<span class="token punctuation">.</span><span class="token number">6</span> <span class="token punctuation">(</span><span class="token number">0x00007f41bff8e000</span><span class="token punctuation">)</span><span class="token operator">/</span>lib64<span class="token operator">/</span>ld<span class="token operator">-</span>linux<span class="token operator">-</span>x86<span class="token operator">-</span><span class="token number">64.</span>so<span class="token punctuation">.</span><span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0x00007f41c0b7c000</span><span class="token punctuation">)</span></code></pre><p>链接静态库</p><p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p><h3><span id="特殊的环境变量-cmake_include_path-和-cmake_library_path">特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</span></h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p><p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p><p>我们还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p><p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p><h1><span id="本人所有视频和笔记都是免费分享给大家的制作视频和笔记要花费大量的时间成本">本⼈所有视频和笔记都是免费分享给⼤家的，制作视频和笔记要花费⼤量的时间成本</span></h1><p>我也有⽼婆和孩⼦要养，恳求各位观众⽼爷们有经济实⼒的稍微打赏⼀下⼩弟，但不强求，再⼀次感谢。<br>您的打赏，会让我今后有更⼤的动⼒，做出更优质的视频，感谢⼤家的⽀持</p><p><img src="CMake%204f0e9a3fcf9949adab4540191610cf3e/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【数字设计与计算机体系结构】第二版中译个人心得</title>
      <link href="/posts/496fb1b3.html"/>
      <url>/posts/496fb1b3.html</url>
      
        <content type="html"><![CDATA[<h2><span id="175cmos-书p19">1.7.5CMOS 书P19</span></h2><ul><li>CMOS比较擅长构成的门电路是<strong>非门、与非门、或非门、传输门</strong>。</li><li>像与门就用与非门+非门组成。</li></ul><h2><span id="164直流电压传输特性-书p15">1.6.4直流电压传输特性 书P15</span></h2><ul><li>书中谈到选择逻辑电平的合理方法是选择在传输特征曲线斜率$\frac{dV(Y)}{dV(A)}=-1$的位置，对应<strong>图1-25</strong>中的$V_{IL}$和$V_{IH}$。这两个位置被称为单位增益点。在单位增益点选择逻辑电平可以最大化噪声容限。</li><li>个人理解：选择这两个点后，性质与 <strong>图1-25 a)</strong> 的反相器理想曲线会很相似。</li></ul><h2><span id="281复用器">2.8.1复用器</span></h2><ol><li>书P48<ul><li>书中谈到，一个$2^N$个输入的复用器可以通过将合适的输入连接到0或者1的方法来实现任何$N$输入逻辑函数。</li><li>个人理解：$N$输入有$2^N$种可能的组成结果。</li></ul></li></ol><h2><span id="29时序">2.9时序</span></h2><h3><span id="291传播延迟和最小延迟-书p51">2.9.1传播延迟和最小延迟 书P51</span></h3><ul><li>传播延迟$t_{pd}$:<ul><li>定义1：当输入改变直到一个或多个输出达到它们的<strong>最终值</strong>所经历的最长时间。</li><li>定义2：一个信号从输入到输出的 <strong>关键路径(critical path)</strong> 长度。</li></ul></li><li>最小延迟$t_{cd}$:<ul><li>定义1：当一个输入发生变化直到任何一个输出 <strong>开始改变</strong> 的最短时间。</li><li>定义2: 一个信号从输入到输出的 <strong>最短路径(short path)</strong> 长度。</li></ul></li><li>最短控制 - 输出延迟：控制信号的输入到最终输出的时间最小值。当 <strong>数据输入在控制输入前</strong> 到达时，倾向使用该策略。<ul><li>个人理解：由于数据信号先达到，故需要想法设法减少控制信号达到的时间。</li></ul></li><li>最短数据 - 输出延迟：数据信号的输入到最终输出的时间最小值。当 <strong>控制输入在数据输入前</strong> 到达时，倾向使用该策略。</li></ul><h2><span id="3时序逻辑设计">3时序逻辑设计</span></h2><h3><span id="32锁存器和触发器-书p61">3.2锁存器和触发器 书P61</span></h3><ul><li>发展历史<ol><li>交叉耦合的反相器对。特点：有记忆功能，但是没有输入。</li><li>SR锁存器。特点：是交叉耦合的或非门对；当S=R=1时会产生两个输出为0的混乱电路响应；S和R混淆了时间和内容。</li><li>D锁存器。特点：在SR锁存器的基础上将输入分为数据输入D和时钟输入CLK；避免了S和R同时为1的情况；电平敏感。</li><li>D触发器。特点：使用两个D锁存器；在时钟CLK上升沿将数据输入D复制到输出Q。</li><li>寄存器：由共享一个公共$CLK$的一排N个触发器组成。<h3><span id="例34竞争条件-书p68">例3.4竞争条件 书P68</span></h3></li></ol></li><li>过程分析：假设初始状态$CLK=D=1$，通过反相器需要的时间相较与门和或门要长很多。<ol><li>在初始状态$CLK=D=1$下，$Q_{prev}=Q=1$。</li><li>当$CLK=0$时，$N1=0$，此时由于反相器速度很慢，$N2$仍为$0$，故得到$Q=0，Q_{prev}=0$。</li><li>等到$\overline{CLK}=1$时，由于$Q_{prev}=0$，则此时$N2=0$，输出$Q=0$，而不会保持预期值1了。<h3><span id="建立时间约束最大延迟约束和保持时间约束最小延迟约束书p84">建立时间约束（最大延迟约束）和保持时间约束（最小延迟约束）书P84</span></h3></li></ol></li><li>关键是理解两者的思想内涵。注意书中的分析都是基于<strong>R2</strong>展开的；CLK上升沿到达<strong>R1</strong>后，才会开始引起后续的一系列变化。<ol><li><strong>建立时间约束</strong>是为了满足R2的建立时间，即D2必须在不迟于<strong>下一个</strong>时钟沿之前的建立时间稳定。因为它限制了组合逻辑的最大延迟，故又称最大延迟约束。</li><li><strong>保持时间约束</strong>是为了满足R2的保持时间，即输入D2必须保持不变直到<strong>本次</strong>时钟沿满足$t_{hold}$的要求。因为它限制了组合逻辑的最小延迟，故又称最小延迟约束。</li><li>引入时钟偏移$ t_{skew} $后，务必抓住前面两点理解。要尽量减少时钟偏移。</li><li>$t_{cd}$和$t_{pd}$是设计师可以控制的变量，一般是通过增减组合路径上的门电路数确定。其他变量一般由制造商确定。<h3><span id="分辨时间-书86">分辨时间 书86</span></h3></li></ol></li><li>书中的公式$P(t_{res}&gt;t)=\frac{T_{0}}{T_{c}}e^{-\frac{t}{\tau}}$<br>分析：$T_{c}$为时钟周期，$\tau$和$T_{0}$由触发器的属性决定。一般来说取$t = t_{pcq}$时，该公式的概率将达到一个很高的值。</li><li>分辨时间是指输出从亚稳态到稳态的时间。</li><li>书P90的公式（3-25）推导：$P(t_{res}&gt;t)=\frac{T_{0}}{T_{c}}e^{-\frac{t}{\tau}}$将$t = T_{c}-t_{setup}$代入即可。</li></ul><h2><span id="5-数字模块">5. 数字模块</span></h2><h3><span id="先进进位加法器-书p147">先进进位加法器 书P147</span></h3><ul><li>超前进位加法器的思想是<strong>并行计算进位</strong>，以缩短关键路径。<br>主要公式：进位信号<script type="math/tex">C_i = A_iB_i + B_iC_{i-1} + A_iC_{i-1} = A_iB_i + (A_i+B_i)C_{i-1}=G_i+P_iC_{i-1}</script><h3><span id="556-只读存储器-书p165">5.5.6 只读存储器 书P165</span></h3></li><li>书中原理：为了读ROM位单元，<strong>位线</strong>被缓慢的拉至高电平1。随后打开<strong>字线</strong>（即赋值为1，这样会打开NMOS），如果晶体管存在，则位线会接地变为低电平0；如果晶体管不存在，则仍然保持高电平1。</li><li>一个$2^N字\times M位$的存储器可以实现任何$N$输入和$M$输出的组合逻辑功能，这种用于执行逻辑的存储阵列称为<strong>查找表(LUT)</strong>。</li><li>这里的<strong>字</strong>仅仅是代表存储器的行，对应的<strong>位</strong>代表列。</li></ul><h2><span id="6-体系结构">6. 体系结构</span></h2><h3><span id="632-i类型指令-书p189">6.3.2 I类型指令 书P189</span></h3><ul><li>为什么补码进行扩展一般是用符号扩展？原因是符号扩展不改变补码的值。例：<pre class="language-none"><code class="language-none">001 符号扩展为 000 001  ——&gt; 原码值为000 001即+1101 符号扩展为 111 101  ——&gt; 原码值为100 011即-3</code></pre></li></ul><h2><span id="7-微体系结构">7. 微体系结构</span></h2><h3><span id="711-体系结构状态和指令集-newbing">7.1.1 体系结构状态和指令集 newbing</span></h3><ul><li>体系结构状态是指计算机体系结构中的<strong>寄存器和内存中的数据</strong>的集合。它反映了计算机在某一时刻的运行状态。不同的指令会改变体系结构状态，例如读写寄存器或内存。体系结构状态与微体系结构状态不同，微体系结构状态是指微处理器内部的数据，例如流水线、缓存、预测等。</li><li>体系结构寄存器是指在指令集中可以使用，提供给程序员使用的寄存器。它们反映了体系结构状态，也就是计算机的运行状态；非体系结构寄存器是指不需要程序员了解，对他们而言是透明的，指令不能直接对这些寄存器使用的寄存器。它们是CPU内部的物理寄存器，用来提高处理器的指令级并行的能力。例如，流水线、缓存、预测等都涉及非体系结构寄存器2。<h3><span id="733-更多指令-书p239">7.3.3 更多指令 书P239</span></h3></li><li>扩展主译码器真值表中各个控制信号的含义：<ul><li>RegWrite：是否写寄存器文件。</li><li>RegDst：选择目的寄存器是Instr[20:16]还是Instr[15:11]。</li><li>ALUSrc：选择ALU的输入之一是来自立即数扩展还是寄存器文件。</li><li>Branch：是否为有条件分支指令。</li><li>MemWrite：是否向存储器写数据。</li><li>MemtoReg:选择写入寄存器文件的数据是来自ALU结果还是数据存储器。</li><li>ALUOp:选择ALU计算是否涉及加法、减法或者依赖于funct字段。比如lw rt, imm(rs)中，就涉及imm+$rs的加法，故lw的ALUOp为加法字段。</li><li>Jump:是否为无条件跳转指令。<h3><span id="781-深流水线-书p282">7.8.1 深流水线 书P282</span></h3></li></ul></li><li>例7.11 深流水线中， 指令时间$T_{instruction}$=$T_c*CPI$。</li></ul><hr><h3><span id="2023年3月16日-看完-好书">2023年3月16日 看完 好书</span></h3>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人心得 </tag>
            
            <tag> 数字设计与计算机体系结构 </tag>
            
            <tag> 书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GNU/Linux】Linux入门教程</title>
      <link href="/posts/7eb74ede.html"/>
      <url>/posts/7eb74ede.html</url>
      
        <content type="html"><![CDATA[<h2><span id="未完成">未完成</span></h2><h2><span id="gnulinuxlinux入门教程">【GNU/Linux】Linux入门教程</span></h2><h3><span id="0推荐链接">0.推荐链接</span></h3><p><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a></p><h3><span id="1重要命令">1.重要命令</span></h3><ul><li><code>df /</code> - 查看磁盘分区的使用情况。<strong>df:disk free</strong>。</li><li><code>find . -name "*.[ch]"</code> - 查找当前目录下的.c和.h文件</li><li><code>grep "\bint i\b" {{file-name}}</code> - 查找文件<code>file</code>内<code>int i</code>的位置。</li><li><code>wc {{file}}</code> - 统计文件的行数/单词数/字符数</li><li><code>sudo apt-get install {{tool-name}}</code> - 一键下载安装新工具</li><li><code>wget {{http://www.xxx.com//abc.zip}}</code> - 网站下载文件</li><li><code>iconv -f uft-8 -t gbk {{file-name}}</code> - 将文件file的格式进行转换，例子中是从<code>uft-8</code>转换到<code>gbk</code></li><li>比较两个文件是否完全相同<ul><li>文本文件的比较: <code>vimdiff {{file1}} {{file2}}</code></li><li>非文本文件的比较: <code>diff {{file1}} {{file2}}</code></li><li>很大的文件: <code>md5sum {{file1}} {{file2}}</code> - 两个文件的md5码不一样，就肯定不是同一个文件。</li></ul></li><li><code>find . -name "*.[ch]" | xargs grep "#include" | sort | uniq</code> - 列出<code>.c</code>和<code>.h</code>文件中所有被包含过的头文件。 - <strong>eXtended ARGumentS:xargs</strong> - <code>sort</code>是排序，<code>uniq</code>是去除相同的。<ul><li><strong>推广：可以据此查找任意文件中的任意一段代码。</strong></li></ul></li><li><code>strace {{program}}</code> - system call trace, 记录程序运行过程中的系统调用信息<ul><li>如<code>strace ls</code>。查看<code>ls</code>命令的系统调用信息。</li><li>通过观察程序运行过程中发生的系统调用，可以大致了解程序关键行为。</li></ul></li><li><code>rm -rf *</code>删除当前目录下的所有文件。</li><li><code>cat {{file}}</code>打印文件中的内容。</li><li><code>echo "" &gt; {{file}}</code>将文件中的内容清空。原理是将””输入到文件内。</li><li><code>touch {{file}}</code>创建文件。</li><li><code>tree</code>显示当前目录下的目录树。</li><li><code>rm ./*.txt</code>删除当前目录下的所有.txt文件。</li></ul><hr><h3><span id="2-makefile的基本操作">2. Makefile的基本操作</span></h3><h4><span id="0-推荐阅读">0. 推荐阅读</span></h4><ul><li><strong>推荐当作字典使用：</strong><a href="https://seisman.github.io/how-to-write-makefile/introduction.html#id9">跟我一起写Makefile!</a></li><li><a href="https://makefiletutorial.com/#makefile-cookbook">Makefile Tutorial By Example</a></li><li><strong>推荐首次阅读：</strong><a href="https://opensource.com/article/18/8/what-how-makefile">What is a Makefile and how does it work?</a><h4><span id="1-基本语法">1. 基本语法</span></h4><pre class="language-none"><code class="language-none">.PHONY: all say_hello generate clean#.DEFAULT_GOAL := generateall: say_hello generatesay_hello:@echo "Hello World"generate:@echo "Creating empty text files..."touch file-{1..10}.txtclean:@echo "Cleaning up..."rm *.txt</code></pre></li><li>Makefile的典型规则语法<pre class="language-none"><code class="language-none">target: prerequisites&lt;TAB&gt; recipe</code></pre></li><li><code>#</code>是注释符。</li><li>回到上面的例子，当执行<code>make</code>时，会显示整个命令<code>echo 'Hello World'</code>，然后是实际的命令输出。我们通常不希望这样。为了抑制回显实际的命令，我们需要用<code>@</code>阻止回显。在其他命令前使用<code>@</code>是同样的功能。</li><li>只有Makefile中的第一个目标是默认目标。通常称为默认目标，这就是您将<code>all</code>视为大多数项目中第一个目标的原因。调用其他目标是所有人的责任。我们可以使用一个名为<code>.DEFAULT_GOAL := &lt;target&gt;</code>的特殊虚假目标来覆盖此行为，即通过该命令切换默认目标。</li><li><code>.PHONY</code>后面跟的目标都被称为伪目标，也就是说我们<code>make</code>命令后面跟的参数如果出现在<code>.PHONY</code>定义的伪目标中，那就直接在Makefile中就执行伪目标的依赖和命令。不管Makefile同级目录下是否有该伪目标同名的文件，即使有也不会产生冲突。另一个就是提高执行makefile时的效率。<h4><span id="2-变量赋值">2. 变量赋值</span></h4><pre class="language-none"><code class="language-none">#x = foo#y = $(x) #x = xyzx := fooy := $(x) x := xyzall:@echo "$(y)"</code></pre></li><li><code>$(x)</code>是对<code>foo</code>的变量引用。</li><li>使用<code>:=</code>是简单赋值，即非递归，使用的是<code>y := $(x)</code>时<code>x</code>的值，即<code>foo</code>；使用<code>=</code>是递归赋值，使用的是<code>x</code>的最终值，即<code>xyz</code>。</li></ul><h4><span id="3实例">3.实例</span></h4><pre class="language-none"><code class="language-none"># Usage:# make        # compile all binary# make clean  # remove ALL binaries and objects.PHONY = all cleanCC = gcc# compiler to useLINKERFLAG = -lmSRCS := $(wildcard *.c)BINS := $(SRCS:%.c=%)all: ${BINS}%: %.o@echo "Checking.."${CC} ${LINKERFLAG} $&lt; -o $@%.o: %.c@echo "Creating object.."${CC} -c $&lt;clean:@echo "Cleaning up..."rm -rvf *.o ${BINS}</code></pre><ul><li><code>-lm</code>是链接到数学库的意思。本例不重要。</li><li><code>SRCS := $(wildcard *.c)</code>：<code>$(wildcard pattern)</code>是文件名的函数之一。在本例中将所有扩展名为<code>.c</code>的文件都存储在一个变量<code>SRCS</code>中。</li><li><pre><code>foo := a.o b.o l.a c.obar := $(foo:%.o=%.c)<pre class="language-none"><code class="language-none">  sets ‘bar’ to ‘a.c b.c l.a c.c’.  本例中`BINS := $(SRCS:%.c=%)`将变量`SRCS`中的`.c`文件的文件名全部去除掉`.c`后缀。- `*`是通配符。- `%`实现对任意`target`名称的匹配。- `$@`：目标的名字(target name);`$^`：构造所需文件列表所有所有文件的名字(所有的prerequisites);`$&lt;`：构造所需文件列表的第一个文件的名字(第一个prerequisites);`$?`：构造所需文件列表中更新过的文件(全部的比target更新的prerequisites)。  - eg1:</code></pre>    test1.o: test1.c head.c    &lt;TAB&gt; recipe  <pre class="language-none"><code class="language-none">    中`$@=test1.o`，`$&lt;=test1.c`，`$^=test1.c head.c`---### 3. shell中方便的功能  - 通过上下方向键检索历史命令  - 光标移动    - `A-f`和`A-b`按键来按**单词**移动光标。    - `C-f`和`C-b`按键来按**字符**移动光标    - `C-a`移动到首字符，`C-e`移动到末字符，`C-d`删除当前字符。  - 通过`history`命令查看历史命令    - 通过`!n`(`n`为历史命令的编号)再次执行命令    - 通过`!xxx`再次执行以`xxx`为开头的最近一条命令  - 通过`cd -`返回上一个工作目录  - 通配符    - `*`为任意长度的任意字符串    - `?`为任意一个字符    - `[]`为集合中的任意一个字符  - 括号拓展    - `{}`。例如`echo Hello-{a,bb,cc}-{1,2}`---### 4. 任务管理   - `C-z` - 停止当前任务   - `bg %{{任务编号}}` - 将指定任务编号的任务在后台运行     - 或者在写命令的时候，在末尾加上`&amp;`。例如`sleep 100 &amp;`   - `fg %{{任务编号}}` - 将指定任务编号的任务在前台运行   - `jobs` - 任务栏   - `kill -9 %{{任务编号}}` - 将指定任务编号的任务杀死   - 任务管理器     - `top` - 非图形化任务管理器     - `htop` - 图形化任务管理器     - `ps` - 最简洁的形式### 输入输出重定向  - 查看进程打开的文件    - Linux上的程序在运行时默认打开了3个文件, 通过 “文件描述符”来编号:      - 0号文件 - 标准输入(默认为当前终端)      - 1号文件 - 标准输出(默认为当前终端)      - 2号文件 - 标准错误(默认为当前终端)    - 通过`ps`查看所有的进程号，通过`lsof -p {{PID}}`来查看打开的文件。    - 使用输入输出重定向后，`lsof -p {{PID}}`来查看进程打开的文件，会发现对应的0号文件和1号文件会变化。  - 向文件追加输出`ls &gt;&gt; result.txt`  - 可将标准错误重定向到文件  - 标准错误一般用于报告错误信息   `ls 2&gt; /dev/null`  - 将标准输入重定向到文件, 无需手动输入   `sort &lt; result.txt`### 管道 = 一个用于连接程序间输入输出的缓冲区  - 示例图:</code></pre>+-------+  stdout   +------+  stdin   +-------+| prog1 | --------&gt; | pipe | -------&gt; | prog2 |+-------+           +------+          +-------+</code></pre><ul><li>例:<br><code>yes | cat &gt; /dev/null</code>通过lsof查看打开的文件</li><li><code>xargs</code>: 一个特殊的命令, 可以将标准输入转变为命令的参数<h3><span id="编程">编程</span></h3><ul><li>写脚本<ul><li><code>if, for, while, case…</code>等控制流</li><li>变量赋值和引用</li><li>函数定义和调用</li><li>内建命令</li></ul></li><li>写C程序<ul><li>命令行参数 = main()函数的参数</li><li>用<code>getopt()</code>库函数识别并处理参数</li><li>用<code>fopen()</code>打开文件</li><li>用<code>fscanf()/fread()</code>从标准输入读取</li><li>用<code>fprintf()/fwrite()</code>将结果写入到标准输出</li><li><code>main()</code>函数的返回值 = 命令的返回值</li><li><code>main()</code>函数的原型<br><code>int main(int argc, char *argv[], char *envp[]);</code><h3><span id="rtfm">RTFM</span></h3></li></ul></li></ul></li><li>查阅命令/库函数/系统文件等内容的手册</li><li><code>man man</code> - 学习如何RTFM</li><li><code>man ls</code> - 查看如何使用ls命令</li><li><code>man 3 printf</code> - 学习如何使用库函数printf</li><li><code>man -k xxx</code> - 检索含有关键字含有xxx的命令</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
            <tag> 入门 </tag>
            
            <tag> 未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【旅游】重庆旅游攻略</title>
      <link href="/posts/314c5eec.html"/>
      <url>/posts/314c5eec.html</url>
      
        <content type="html"><![CDATA[<h2><span id="重庆旅游202326-2023210元宵后">重庆旅游（2023.2.6 - 2023.2.10）（元宵后）</span></h2><h3><span id="民宿选择">民宿选择</span></h3><p>民宿是在<strong>途家民宿</strong>APP上找的，位置在观音桥。<br><img src="/img/重庆旅游攻略/民宿的落地窗.jpg" alt="民宿窗外"><br>相较解放碑，观音桥附近的民宿性价比更高，小红书上说这里是重庆本地人的聚集地。<br>附近有观音桥商圈，公共交通（地铁）也比较附近。有个<strong>红旗沟长途汽车站</strong>可以通往郊区的景点，比如统景温泉（<strong>房东说的</strong>），不过我们没有去郊区玩。</p><h3><span id="推荐美食">推荐美食</span></h3><ul><li>观音桥<ul><li>观音桥的<strong>鹞子丘眼镜火锅</strong>，非常好吃！我两连续吃了三天！<br><img src="/img/重庆旅游攻略/眼镜火锅.jpg" width="30%" height="30%" alt="眼镜火锅"> </li><li>观音桥的<strong>小弟面馆</strong>，挨着鹞子丘眼镜火锅，面馆不大，吃的本地人很多，应该是正宗的重庆面馆。不过我两感觉正宗重庆小面的味道也一般般。<br><img src="/img/重庆旅游攻略/小弟面馆.jpg" width="30%" height="30%" alt="小弟面馆"><br><img src="/img/重庆旅游攻略/小弟面馆的重庆小面.jpg" width="30%" height="30%" alt="小弟面馆的重庆小面"> </li></ul></li><li>解放碑<ul><li>解放碑的<strong>八一好吃街外</strong>的甜筒，忘记啥名字了。我两炫了两根，一根原味一根巧克力。<br><img src="/img/重庆旅游攻略/甜筒.jpg" width="30%" height="30%" alt="甜筒"> </li><li>解放碑的<strong>好又来酸辣粉</strong>，10元一碗酸辣粉，特别好吃！</li><li><strong>陈昌银麻花</strong>也可以。不过淘宝上有卖。</li></ul></li></ul><h3><span id="推荐景点">推荐景点</span></h3><ul><li>沙坪坝<ul><li><strong>融汇温泉</strong>力荐！200左右一人（包一餐）。我两在里面吃的中餐，味道还不错。<br>温泉种类很多，我们去的时候人不算多，温泉水质比较好。里面的环境和配套设施也非常完善。<br>服务特别棒！我两刚下车，门口就有服务员给我们开车门，然后领路！<br>2楼有餐厅和配套休息室！我两中午到的，就先在2楼的休息室睡了一觉，很舒服！</li></ul></li><li>解放碑商圈<ul><li>即八一好吃街附近。里面吃的多，玩的也有一些。老婆在一个商城里面玩了好一阵子，开心。<br><img src="/img/重庆旅游攻略/树.jpg" width="30%" height="30%" alt="拍的树"><br><img src="/img/重庆旅游攻略/人民解放碑.jpg" width="30%" height="30%" alt="人民解放碑"><br><img src="/img/重庆旅游攻略/八一好吃街.jpg" width="30%" height="30%" alt="八一好吃街"> </li></ul></li><li>观音桥商圈<br>和解放碑商圈比较类似。不过外地人不来也挺可惜的。里面的价格相较解放碑商圈也便宜些。<br>里面有两个仿冒茶颜悦色的奶茶品牌，一个叫霸王茶姬，一个叫初茶花月。初茶花月的logo是真的巨丑，不过里面喝的仿·幽兰拿铁的味道还不错。</li></ul><h3><span id="避坑">避坑</span></h3><ul><li>洪崖洞<br><strong>洪崖洞千万不要去</strong>，就是一坨shit，里面没什么玩的，还人挤人！在网上看看图片就好！下面是我两在洪崖洞附近拍的图。<br><strong>cover的图就是洪崖洞</strong>，在里面玩可拍不出这种效果。<br><img src="/img/重庆旅游攻略/重庆大剧院.jpg" width="30%" height="30%" alt="重庆大剧院"><br><img src="/img/重庆旅游攻略/洪崖洞灯笼.jpg" width="30%" height="30%" alt="洪崖洞灯笼"> </li></ul><h3><span id="房东推荐的攻略">房东推荐的攻略</span></h3><p>放在这篇博客里面啦！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wzm </tag>
            
            <tag> tyh </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GNU/Linux】Missing Semester</title>
      <link href="/posts/341ca211.html"/>
      <url>/posts/341ca211.html</url>
      
        <content type="html"><![CDATA[<h3><span id="未完成">未完成</span></h3><h2><span id="1-lecture-1-course-overview-the-shell">1 Lecture 1: Course Overview + The Shell</span></h2><ul><li><a href="https://missing-semester-cn.github.io/2020/course-shell/">笔记</a></li><li><a href="https://www.youtube.com/watch?v=Z56Jmr9Z34Q&amp;t=10s">网课</a><h3><span id="11-输入输出流重定向">1.1 输入输出流重定向</span></h3></li><li>一般来说，Shell的输入流默认是指键盘输入，而输出流默认是终端。Shell给了程序员一种重新连接输入输出流的方式。<ul><li>最直接的方法是使用尖括号<code>&lt; fileA &gt; fileB</code>，其中 <code>&lt;</code> 代表重新定义输入流， <code>&gt;</code> 代表重新定义输出流。<ul><li>举例: 将hello.txt文件复制到hello2.txt<br><code>$ cat &lt; hello.txt &gt; hello2.txt</code></li><li>解释：<ul><li><code>$ cat file</code> 含义是将文件输入直接连接到输出，比如 <code>$ cat hello.txt</code>是直接将输入<code>hello.txt</code>连接到默认的输出流终端。</li><li><code>$ cat &lt; hello.txt &gt; hello2.txt</code>是首先执行<code>cat &lt; hello.txt</code>，即将<code>cat</code>的输入流重定向为<code>hello.txt</code>，然后执行<code>&gt; hello2.txt</code>，即将<code>cat</code>的输出流重定向为<code>hello2.txt</code>。实现功能与<code>$ cp hello.txt hello2.txt</code>一致。</li></ul></li><li>举例：<code>&gt;</code>具有覆盖原文件的效果。若不想进行覆盖，而只是追加，则使用<code>&gt;&gt;</code>。</li></ul></li></ul></li></ul><h3><span id="12-同时执行与管道传参">1.2 <code>;</code>同时执行与<code>|</code>“管道”传参</span></h3><ul><li>如果有同时执行多条命令的需要，即可以使用<code>;</code><ul><li>举例：同时执行<code>ls</code>和<code>ls -a</code><br><code>$ ls ; ls -a</code></li><li>解释：用<code>;</code>隔开每个命令后，每个命令按照从左到右的顺序，顺序执行，彼此之间不关心是否失败， 所有命令都会执行。</li></ul></li><li><code>|</code>主要用于参数传递。即使用<code>|</code>后，上一条命令的输出，作为下一条命令参数。<ul><li>举例：<code>$ tee</code>命令基于标准输入读取数据，标准输出或文件写入数据。<br><code>$ echo hello | tee hello.txt</code><pre class="language-none"><code class="language-none">hello</code></pre></li><li>解释： <code>echo hello | tee</code>将<code>echo hello</code>的输出作为<code>tee</code>的输入，同时<code>tee hello.txt</code>能够在把输入写入到hello.txt的同时，并且在默认输出即终端上打印。<h3><span id="13-内核参数sys和超级特权态sudo-su">1.3. 内核参数<code>sys</code>和超级特权态<code>sudo su</code></span></h3></li></ul></li><li><code>sys</code>并不是文件，它是集成好的内核参数<ul><li>举例：访问方式:<br><code>$ cd /sys</code><pre class="language-none"><code class="language-none">block  class  devices   fs          kernel  powerbus    dev    firmware  hypervisor  module</code></pre></li><li>解释：里面的各种参数都是与硬件设置相关，用户态下不允许对里面的各种文件进行修改。如果想要操作，必须进入超级特权态。</li></ul></li><li><code>$ sudo su</code>进入超级特权态<ul><li>举例：在用户态下，命令行显示的都是<code>$</code>，使用<code>$ sudo su</code>后，进入超级特权态，命令行的显示变成<code>#</code>。退出使用<code># exit</code></li><li>解释：不需解释。</li></ul></li></ul><h2><span id="2-lecture-1-course-overview-the-shell">2 Lecture 1: Course Overview + The Shell</span></h2><ul><li><a href="https://missing-semester-cn.github.io/2020/shell-tools/">笔记</a></li><li><a href="https://www.youtube.com/watch?v=kgII-YWo3Zw">网课</a><h3><span id="21-单引号-和双引号">2.1 单引号 <code>''</code>和双引号<code>""</code></span></h3><ul><li>举例:<code>$foo=bar 注释： 注意不能写出foo=bar</code><br>则使用<code>$echo "Value is $foo"</code>输出<code>Value is bar</code>；使用<code>$echo 'Value is $foo'</code>输出<code>Value is $foo</code>。</li><li>解释:以<code>''</code>定义的字符串为原义字符串，其中的变量不会被转义，而 <code>""</code>定义的字符串会将变量值进行替换。</li><li>举例:<pre class="language-none"><code class="language-none">$ vim mcd.sh注释：此时进入mcd.sh文件中mcd(){    mkdir -p "$1" # 创建名为传入的第一个参数的目录    cd "$1"       # 进入该目录}注释: 退出vim后$ source mcd.sh 注释：这条命令是加载mcd.sh$ mcd test      注释：创建名为test的目录，并且进入该目录</code></pre></li><li>解释：<br>这里 <code>$1</code> 是脚本的第一个参数。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考<a href="https://tldp.org/LDP/abs/html/special-chars.html">here</a>。<ul><li><code>$0 - 脚本名</code></li><li><code>$1到$9 - 脚本的参数。 $1 是第一个参数，依此类推。</code></li><li><code>$@ - 所有参数</code></li><li><code>$# - 参数个数</code></li><li><code>$? - 前一个命令的返回值</code></li><li><code>$$ - 当前脚本的进程识别码</code></li><li><code>!! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。</code></li><li><code>$_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。</code></li></ul></li></ul></li><li>举例:  <pre class="language-none"><code class="language-none">注释：想在mcd.sh脚本中查找foobar字符，由于没有，肯定查找失败。通过echo $?输出上一条指令的错误代码，由于错误，所以返回1。如果正确会返回0$ grep foobar mcd.sh$ echo $?1 注释：||和&amp;&amp;都属于短路运算符，用来进行条件判断。注释：使用||时，如果前面的命令返回true(即0)，那么后面的命令会被短路；使用&amp;&amp;时，如果前面的命令返回false(即非0),那么后面的命令将会被短路。$ false || echo "Oops, fail"Oops, fail$ true || echo "Will not be printed"无输出$ true &amp;&amp; echo "Things went well"Things went well$ false &amp;&amp; echo "Will not be printed"无输出$ false ; echo "This will always run"This will always run</code></pre><h3><span id="22-cmd和ltcmd">2.2 <code>$(CMD)</code>和<code>&lt;(CMD)</code></span></h3><ul><li>举例：<pre class="language-none"><code class="language-none">$ echo $(date)2023年 02月 16日 星期四 22:18:32 CST$ diff &lt;(ls foo) &lt;(ls bar)注释：会显示目录foo和bar中文件的区别</code></pre></li><li>解释：<br>当您通过 <code>$( CMD )</code> 这样的方式来执行<code>CMD</code>这个命令时，它的输出结果会替换掉 <code>$( CMD )</code>。例如，如果执行 <code>for file in $(ls)</code> ，shell首先将调用<code>ls</code> ，然后遍历得到的这些返回值。还有一个冷门的类似特性是进程替换（process substitution），<code>&lt;( CMD )</code>会执行 <code>CMD</code> 并将结果输出到一个 <strong><em>临时文件</em></strong> 中，并将 <code>&lt;( CMD )</code> 替换成 <strong><em>临时文件名</em></strong> 。这在我们希望返回值通过文件而不是<code>STDIN</code>传递时很有用。例如， <code>diff &lt;(ls foo) &lt;(ls bar)</code> 会显示文件夹 <code>foo 和 bar</code> 中文件的区别。</li><li>举例：下面这个例子展示了一部分上面提到的特性。这段脚本会遍历我们提供的参数，使用<code>grep</code>搜索字符串 <code>foobar</code>，如果没有找到，则将其作为注释追加到文件中。<pre class="language-none"><code class="language-none">#!/bin/bashecho "Starting program at $(date)" # date会被替换成日期和时间echo "Running program $0 with $# arguments with pid $$" ## $0为for file in "$@"; do    grep foobar "$file" &gt; /dev/null 2&gt; /dev/null    # 如果模式没有找到，则grep退出状态为 1    # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息    if [[ $? -ne 0 ]]; then        echo "File $file does not have any foobar, adding one"        echo "# foobar" &gt;&gt; "$file"    fidone</code></pre>./example.sh mcd.sh script.py example.sh</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
            <tag> youtube网课 </tag>
            
            <tag> 未完成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【Vivado】ROM IP核的使用</title>
      <link href="/posts/ab5b7cc3.html"/>
      <url>/posts/ab5b7cc3.html</url>
      
        <content type="html"><![CDATA[<ul><li><h3><span id="rom-ip核的创建方法"><strong>ROM IP核的创建方法</strong></span></h3><img src="https://foruda.gitee.com/images/1675436593019752405/109dae0b_6531589.png" alt="1" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703461077393/b393cba0_6531589.png" alt="2" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703187128425/c590353a_6531589.png" alt="3" title="屏幕截图"><br><img src="https://foruda.gitee.com/images/1675436703029907655/40f1f38a_6531589.png" alt="4" title="屏幕截图"><br>然后点击确定，就能生成一个ROM IP核。</li></ul><hr><ul><li><h3><span id="rom-ip核的调用方法"><strong>ROM IP核的调用方法</strong></span></h3><img src="https://foruda.gitee.com/images/1675436918059218885/ace5fdad_6531589.png" alt="1" title="屏幕截图"><br>由于ROM IP核是在 _上升沿_ 读数据，所以如果要将从ROM读的数据写入到其他地方的话，可以在时钟的 _下降沿_ 写数据，具体操作如下：<pre class="language-none"><code class="language-none">// clk下降沿进行address自增，下一个上升沿在rom进行读数据always @(negedge clk) begin // rom是clk上升沿读，所以这里一定要是下降沿！    if (rst) begin // 同步复位        addra_7bit &lt;= 0;        in &lt;= 0;    end    else begin        // 将上个上升沿读的数据写入        in[addra_7bit] &lt;= wave_douta;         if(addra_7bit &lt; (len-1)) begin            addra_7bit &lt;= addra_7bit + 1'b1;        end        else begin            addra_7bit &lt;= 0;        end    endendrom_wave_64w_128d rom_wave (    // 上升沿读数据    .clka(clk),      .addra(addra_7bit),      .douta(wave_douta) ![输入图片说明](https://foruda.gitee.com/images/1675437561499899947/cd9436de_6531589.png "屏幕截图"));</code></pre></li></ul><hr><ul><li><h3><span id="rom-ip核的注意事项"><strong>ROM IP核的注意事项</strong></span></h3></li></ul><ol><li>IP核设置的width可以比实际coe内的数据的width更宽，但是depth必须和实际coe文件内的数据一致。</li><li>当更新coe文件后，必须在IP核配置界面重新LOAD FILE，如下图：<br><img src="https://foruda.gitee.com/images/1675437570773333850/2a2dd185_6531589.png" alt="2" title="屏幕截图"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vivado </tag>
            
            <tag> IC设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【VMware】VMware与Windows无法相互拖拽文件、粘贴复制的解决办法</title>
      <link href="/posts/6820c6bc.html"/>
      <url>/posts/6820c6bc.html</url>
      
        <content type="html"><![CDATA[<p>在虚拟机的命令行输入以下命令：<br></p><pre class="language-none"><code class="language-none">$sudo apt-get autoremove open-vm-tools</code></pre><br><pre class="language-none"><code class="language-none">$sudo apt-get install open-vm-tools-desktop</code></pre><br><pre class="language-none"><code class="language-none">$sudo reboot</code></pre><br>并且打开共享文件夹即可<p></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【GNU/Linux】Unified Format</title>
      <link href="/posts/6393c1cf.html"/>
      <url>/posts/6393c1cf.html</url>
      
        <content type="html"><![CDATA[<h2><span id="该格式用来对比修改前和修改后的两个文件的差异">该格式用来对比修改前和修改后的两个文件的差异</span></h2><p><img src="https://foruda.gitee.com/images/1676295492065282810/c43f014d_6531589.png" alt="1" title="1.png"><br>可以看出图中的两个文件 _lao_ 和  _tzu_ 中的字段有一些差异。<br>使用命令<code>diff -u lao tzu</code>后输出如下图：<br><img src="https://foruda.gitee.com/images/1676295542401435909/f188388c_6531589.png" alt="2" title="2.png"><br>首段的<br></p><pre class="language-none"><code class="language-none">--- lao 2002-02-21 23:30:39.942229878 -0800+++ tzu2002-02-21 23:30:50.442260588 -0800</code></pre><br>代表_lao_文件是<code>-</code>表征，_tzu_文件是<code>+</code>表征。<br><pre class="language-@@" data-language="@@"><div class="caption"><span>-1,7 +1,6 @@```和```@@ -9,3 +8,6 @@```代表该对比段在源文件中的【块起始行，块所占行数】。后面的代码中，如</span></div><code class="language-@@">```-The Way that can be told of is not the eternal Way;-The name that can be named is not the eternal name. The Nameless is the origin of Heaven and Earth;-The Named is the mother of all things.+The named is the mother of all things.</code></pre><br>所示，<code>-</code>代表是_lao_文件中独有的，<code>+</code>代表是_tzu_文件中独有的。没有<code>+</code>或<code>-</code>的字段代表是两个文件共有的。<p></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切的开始</title>
      <link href="/posts/25e1c0d9.html"/>
      <url>/posts/25e1c0d9.html</url>
      
        <content type="html"><![CDATA[<h3><span id="我和我的最爱">我和我的最爱！</span></h3><p><img src="/img/tang/pic1.jpg" width="30%" height="30%" alt="tyh&amp;wzm"></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wzm </tag>
            
            <tag> tyh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【git】git部分重要命令</title>
      <link href="/posts/cff33c4a.html"/>
      <url>/posts/cff33c4a.html</url>
      
        <content type="html"><![CDATA[<h2><span id="0推荐链接">0.推荐链接</span></h2><p><a href="http://onlywei.github.io/explain-git-with-d3/#branch">GIT可视化</a></p><ol><li><p>显示当前目录位置:<code>$:pwd</code></p></li><li><p>显示当前目录文件，包括隐藏文件:<code>$:ls-ah</code></p></li><li><p>git本地仓库初始化：<code>$:git init</code>初始化，产生<code>.git</code>隐藏文件夹</p></li><li><p>git本地仓库添加文件</p><ul><li>添加单一文件:<code>$:git add &lt;文件名&gt;</code>;</li><li>添加所有文件:<code>$:git add .</code>;</li></ul></li><li><p>git本地提交变更:<code>$:git commit -m "输入对应信息"</code>;</p><ul><li>对应信息的标准规范举例:<code>"fix(test): change contest"</code>,意为修改了test文件。</li></ul></li><li><p>git查看本地仓库信息:</p><ul><li>查看本地commit信息:<code>$:git log</code>;</li><li>查看本地文件修改信息:<code>$:git status</code>;</li><li>查看本地所有分支:<code>git branch -a</code></li></ul></li><li><p>git本地回退commit版本：<code>$:git reset --hard &lt;commit_id&gt;</code>;</p><ul><li>使用<code>$:git log</code>可以看到<code>&lt;commit_id&gt;</code></li><li>回退版本后，本地仓库内容会变化。</li></ul></li><li><p>git本地分支操作</p><ul><li>创建分支：<code>$:git branch &lt;分支名&gt;</code>;</li><li>切换到指定分支:<code>$:git branch &lt;分支名&gt;</code>;</li><li>查看本地所有分支:<code>$:git branch -a</code></li><li>删除一个本地分支:<code>$:git branch -d &lt;分支名&gt;</code></li><li>查看所有本地分支与远程分支的连接关系：<code>$ git branch -vv</code></li><li>指定当前分支与远程分支连接:<ul><li><code>$git branch --set-upstream-to=&lt;远程仓库别名&gt;/&lt;远程分支名&gt;</code></li><li>如<code>$git branch --set-upstream-to=origin/Group04-Test06-stable</code></li></ul></li><li>推送本地指定分支A的内容到远程分支B：<ul><li><code>$ git push &lt;远程仓库别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></li><li>如：<code>$git push origin master:Group04-Test06-stable</code></li></ul></li></ul></li><li><p>git本地合并分支</p><ul><li>将<code>分支1</code>与<code>当前分支</code>合并：<code>$:git merge &lt;分支名1&gt;</code></li></ul></li><li><p>git克隆远程仓库到本地:<code>$:git clone &lt;复制的远程仓库地址&gt;</code></p></li><li><p>git将commit后的本地仓库推送到远程仓库:</p><ul><li>将commit后的本地仓库的<code>分支名</code>推送到远程仓库<code>&lt;远程仓库别名&gt;</code>:<code>$:git push &lt;远程仓库别名&gt; &lt;分支名&gt;</code></li></ul></li><li><p>git将远程仓库下载到本地仓库:</p><ul><li>拉取当前连接的远程仓库下载到本地仓库:<code>$:git pull</code></li></ul></li><li><p>git准备将本地仓库push到远程仓库，但是因为这个过程之前有人已经修改过了远程仓库，从而导致版本不一致:</p><ol><li>先获取远程更新:<code>$:git fetch upstream</code></li><li>把远程更新合并到自己的分支中:<code>$:git merge upstream/&lt;自己分支名&gt;</code></li><li>再将本地仓库push到远程仓库:<code>$:git push</code></li></ol></li><li><p>git查看当前连接的远程仓库:<code>$:git remote</code></p></li><li><p>git发行版本:</p><ul><li>为commit后的本地仓库后打上tags:<code>$:git tag -a &lt;版本号&gt; -m "&lt;备注信息&gt;"</code></li><li>推送标签到远程分支:<code>$:git push &lt;远程仓库别名&gt; &lt;版本号&gt;</code></li><li>删除本地标签:<code>$:git tag -d &lt;版本号&gt;</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
